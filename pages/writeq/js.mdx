## 如何实现new？
```js
```
## 如何实现call？
```js
// call实现，const args = [...arguments].slice(1)
Function.prototype.myCall = function (context, ...args) {
    const s = Symbol()
    context[s] = this // 该this指向的是调用的函数，函数也是对象
    const res = context[s](...args) // 此时该函数内的this指向的就是context了
    delete context[s]
    return res
}
```
## 如何实现promise/async？
* 通过构造函数生成一个promise对象，该构造函数有一个延时函数参数
* 通过promise.then()或promise.catch()方法实现结果获取
* then函数和catch函数可以链式调用
```js
function MyPromise(func) {
    this.status = 'pending';
    this.res = '';
    this.thenCbs = [];
    this.catchCbs = [];
    const resolve = (data) => {
        this.status = 'fulfilled';
        this.res = data;
        this.thenCbs.forEach(cb => {
            cb(this.res);
        });
    }
    const reject = (data) => {
        this.status = 'rejected';
        this.res = data;
        this.catchCbs.forEach(cb => {
            cb(this.res);
        });
    }
    this.then = function (cb) {
        if (this.status == 'pending') {
            this.thenCbs.push(cb);
        }
        if (this.status == 'fulfilled') {
            var res = cb(this.res)
        }
        return this;
    }
    this.catch = function (cb) {
        if (this.status == 'pending') {
            this.catchCbs.push(cb)
        }
        if (this.status == 'rejected') {
            var res = cb(this.res)
        }
        return this;
    }
    func(resolve, reject)
}
```
## 如何实现async/await？
* 理解async函数需要先理解Generator函数，因为async函数是Generator函数的语法糖。
```js
function co(gen) {
  return new Promise((resolve, reject) => {
    const g = gen();
    function next(param) {
      const { done, value } = g.next(param);
      if (!done) {
        // 未完成 继续递归
        Promise.resolve(value).then((res) => next(res));
      } else {
        // 完成直接重置 Promise 状态
        resolve(value);
      }
    }
    next();
  });
}
function* readFile() {
  const value = yield promise1();
  const result = yield promise2(value);
  return result;
}
co(readFile).then((res) => console.log(res));
```
