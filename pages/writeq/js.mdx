## 如何实现new？
```js
function myNew(Fun, ...args) {
    let obj = {};
    obj.__proto__ = Fun.prototype;
    let res = Fun.apply(obj, args); // 最关键的一步
    return (res instanceof Object ? res : obj);
}
let obj = myNew(One, "XiaoMing", "18");
console.log("newObj:", obj);
```
## 如何实现call？
```js
Function.prototype.myCall = function (context, ...args) {
    const s = Symbol()
    context[s] = this // 该this指向的是调用的函数`func.myCall(...)`
    const res = context[s](...args) // 此时该函数内的this指向的就是context了
    delete context[s]
    return res
}
```
## 如何实现promise？
```js
function MyPromise(func) {
    this.status = 'pending';
    this.res = '';
    this.thenCbs = [];
    this.catchCbs = [];
    const resolve = (data) => {
        this.status = 'fulfilled';
        this.res = data;
        this.thenCbs.forEach(cb => {
            cb(this.res);
        });
    }
    const reject = (data) => {
        this.status = 'rejected';
        this.res = data;
        this.catchCbs.forEach(cb => {
            cb(this.res);
        });
    }
    this.then = function (cb) {
        if (this.status == 'pending') {
            this.thenCbs.push(cb);
        }
        if (this.status == 'fulfilled') {
            var res = cb(this.res)
        }
        return this;
    }
    this.catch = function (cb) {
        if (this.status == 'pending') {
            this.catchCbs.push(cb)
        }
        if (this.status == 'rejected') {
            var res = cb(this.res)
        }
        return this;
    }
    func(resolve, reject)
}
```
## 如何实现Promise.all/race？
```js
Promise.myAll = function (promises) {
  let arr = [], count = 0
  return new Promise((resolve, reject) => {
    promises.forEach((item, i) => {
      Promise.resolve(item).then(res => {
        arr[i] = res
        count += 1
        if (count === promises.length) resolve(arr)
      }).catch(reject)
    })
  })
}
Promise.MyRace = function (promises) {
  return new Promise((resolve, reject) => {
    for (const item of promises) {
      Promise.resolve(item).then(resolve).catch(reject)
    }
  })
}
```
## 如何实现async/await？
* 理解async函数需要先理解Generator函数，因为async函数是Generator函数的语法糖。
```js
function co(gen) {
  return new Promise((resolve, reject) => {
    const g = gen();
    function next(param) {
      const { done, value } = g.next(param);
      if (!done) {
        // 未完成 继续递归
        Promise.resolve(value).then((res) => next(res));
      } else {
        // 完成直接重置 Promise 状态
        resolve(value);
      }
    }
    next();
  });
}
function* readFile() {
  const value = yield promise1();
  const result = yield promise2(value);
  return result;
}
co(readFile).then((res) => console.log(res));
```
## 手写防抖节流？
* 防抖（debounce）：每次触发定时器后，取消上一个定时器，然后重新触发定时器。防抖一般用于用户未知行为的优化，比如搜索框输入实时提示。
  ```js
  let timer;
  function debounce(cb, time) {
    clearTimeout(timer);
    timer = setTimeout(() => {
        cb();
    }, time)
  }
  
  onInputChange(text) {
    debounce(() => {
      // 获取实时提示
    }, 100)
  }
  ```
  ```js
  // 复杂一点的
  function debounce(func, time) {
    let timer;
    return function() {
      const [that, args] = [this, arguments];
      clearTimeout(timer)
      timer = setTimeout(() => {
        func.apply(that, args);
      }, time);
    }
  }

  onInputChange = debounce((text) => {
    // 获取实时提示
  }, 1000)
  ```
* 节流（throttle）：每次触发定时器后，直到这个定时器结束之前无法再次触发该函数。一般用于可预知的用户行为的优化，比如限制按钮点击的触发频率，防止重复的提交。
```js
let previous = 0;
function throttle(cb, time) {
  const now = Date.now();
  if (now - previous > time) {
    cb();
    previous = now;
  }
}

onButtonClick() {
  throttle(() => {
    // 提交表单
  }, 1000)
}
```
```js
// 复杂一点的
function throttle(func, time) {
  let previous = 0;
  return function() {
    const [that, args] = [this, arguments];
    const now = Date.now();
    if (now - previous > time) {
      previous = now;
      func.apply(that, args);
    }
  }
}
```
## 如何实现一个深拷贝？
```js
// 一个简单的深拷贝
function clone(target) {
    if (typeof target === 'object') {
        let cloneTarget = Array.isArray(target) ? [] : {}; // 考虑数组
        for (const key in target) {
            cloneTarget[key] = clone(target[key]);
        }
        return cloneTarget;
    } else {
        return target;
    }
};
```
## 如何实现assign？
```js
export function assign(target) {
	var sources = [].slice.call(arguments, 1);
	sources.forEach(function (source) {
		if(!source) return;
		Object.getOwnPropertyNames(source).forEach(function(propName) {
			// Object.defineProperty(obj,property,descriptor)
			// getOwnPropertyDescriptor返回一个对象，该对象描述给定对象上特定属性（即直接存在于对象上而不在对象的原型链中的属性）的配置。
			// 返回的对象是可变的，但对其进行更改不会影响原始属性的配置（即不是const的，深拷贝的）。
			Object.defineProperty(target, propName, Object.getOwnPropertyDescriptor(source, propName));
		});
	});
	return target;
}
```
## 如何准确检测一个值是null类型而不是其他类型隐式转换而来？
```js
const getType = (value: any) => {
  const str: string = Object.prototype.toString.call(value)
  const typeStrArray = str.substring(1, str.length - 1).split(' ')
  return typeStrArray[1].toLowerCase()
}
```
## 如何实现rxjs的defer函数？
```js
function defer() {
	this.resolve = null;
	this.reject = null;
	this.promise = new Promise((resolve, reject) => {
		this.resolve = resolve;
		this.reject = reject;
	});
}
```
## 如何实现promise.all？
```js
let p1 = new Promise((resolve) => {
    resolve(1)
})
let p2 = new Promise((resolve) => {
    resolve(2)
})
let pa = Promise.myAll([p1, p2])
pa.then(args => {

})
Promise.myAll = function(...args) {
    let n = 0;
    for (let arg of args) {
        arg.then(() => {
            n += 1
            if (n >= args.length)
                resolve(true)
        })
    }
}
```

## 手写一个Loader？
```js
// 解析css文件并插入到dom中
module.exports = function (content) {
  let str = `
    var style = document.createElement("style");
    style.innerHTML = ${JSON.stringify(content)};
    document.head.appendChild(style);
  `;
  return str;
};
// test: /\.css$/,
// use: [resolve(__dirname, "../loader/testSytleLoader.js")],
```
## 手写一个Plugin插件
```js
const pluginName = 'ConsoleLogOnBuildWebpackPlugin';
class ConsoleLogOnBuildWebpackPlugin {
  constructor(options) {
    console.log("current plugin option is" + JSON.stringify(options))
  }
  apply(compiler) { // apply 方法是一个插件所必须的
    // compiler 继承自 tapable
    // tapable  提供了多种 hooks  https://github.com/webpack/tapable#hook-types
    // run      是 AsyncSeriesHook实例 [tapable提供的多种hooks的一种]
    compiler.hooks.run.tap(pluginName, compilation => {
      console.log('webpack 构建过程开始！');
    });
  }
}

module.exports = ConsoleLogOnBuildWebpackPlugin
```
