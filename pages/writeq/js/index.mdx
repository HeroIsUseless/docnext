## 如何准确检测一个值是null类型而不是其他类型隐式转换而来？
```js
const getType = (value: any) => {
  const str: string = Object.prototype.toString.call(value)
  const typeStrArray = str.substring(1, str.length - 1).split(' ')
  return typeStrArray[1].toLowerCase()
}
```
## 手写防抖节流？
* 防抖（debounce）：每次触发定时器后，取消上一个定时器，然后重新触发定时器。防抖一般用于用户未知行为的优化，比如搜索框输入实时提示。
  ```js
  function debounce(func, time) {
    let timer;
    return function() {
      const [that, args] = [this, arguments]; // 因为有可能是方法在调用，所以保留指针
      clearTimeout(timer)
      // setTimeout内的函数中的this往往指向全局
      // 因为setTimeout里调用这个回调只是普通调用，那么此时的环境是window
      // 箭头函数会帮你把this绑定到声明时的上下文->debounce的上下文->onInputChange的上下文，就不是很有意义了
      timer = setTimeout(() => {
        func.apply(that, args);
      }, time);
    }
  }

  onInputChange = debounce((text) => {
    // 获取实时提示
  }, 1000)
  ```

* 节流（throttle）：每次触发定时器后，直到这个定时器结束之前无法再次触发该函数。一般用于可预知的用户行为的优化，比如限制按钮点击的触发频率，防止重复的提交。
```js
function throttle(func, time) {
  let previous = 0;
  return function() {
    const [that, args] = [this, arguments];
    const now = Date.now();
    if (now - previous > time) {
      previous = now;
      func.apply(that, args);
    }
  }
}
```
## 手写一个Loader？
```js
// 解析css文件并插入到dom中
module.exports = function (content) {
  let str = `
    var style = document.createElement("style");
    style.innerHTML = ${JSON.stringify(content)};
    document.head.appendChild(style);
  `;
  return str;
};
// test: /\.css$/,
// use: [resolve(__dirname, "../loader/testSytleLoader.js")],
```
## 手写一个Plugin插件
```js
const pluginName = 'ConsoleLogOnBuildWebpackPlugin';
class ConsoleLogOnBuildWebpackPlugin {
  constructor(options) {
    console.log("current plugin option is" + JSON.stringify(options))
  }
  apply(compiler) { // apply 方法是一个插件所必须的
    // compiler 继承自 tapable
    // tapable  提供了多种 hooks  https://github.com/webpack/tapable#hook-types
    // run      是 AsyncSeriesHook实例 [tapable提供的多种hooks的一种]
    compiler.hooks.run.tap(pluginName, compilation => {
      console.log('webpack 构建过程开始！');
    });
  }
}

module.exports = ConsoleLogOnBuildWebpackPlugin
```

## 如何获取时区差值？
首先，我们需要获取本地时区与其他时区之间的时间差值。JavaScript提供了一个Date对象，可以获取本地时间和UTC时间之间的差值。我们可以利用这个差值得到本地时间和其他时区时间之间的差值。
```js
// 获取本地时间与UTC时间之间的差值（单位为分钟）
var offset = new Date().getTimezoneOffset();

// 计算将本地时间转换为指定时区所需要加上的分钟数
var timeZoneOffset = offset / 60 + timeZoneDiff; // timeZoneDiff为目标时区与UTC时间之间的差值（单位为小时）
```
有了时区差值，我们就可以将其他时区的时间转换为本地时间了。
```js
// 获取指定时区的本地时间字符串表示形式
function getLocalTimeInTimeZone(timeZoneDiff) {
  var localTime = new Date().getTime() + timeZoneDiff * 60 * 60 * 1000;
  var localTimeStr = new Date(localTime).toLocaleString();
  return localTimeStr;
}

// 转换到目标时区的本地时间
var timeZoneDiff = 8; // 假设目标时区为东八区
var localTimeInTimeZone = getLocalTimeInTimeZone(timeZoneDiff);
```
## 用setTimeout实现setInterval？*
```js
var mySetInterval = function(func, duration){
    function interval(){
        setTimeout(interval, duration);
        func()
    }
    setTimeout(interval, duration);
}
```
## 一个准确的setTimeout/setInterval？*
setTimeout是延迟delay毫秒后, 将回调函数加入事件队列, 事件什么时候执行到此处不一定, 所以会有延迟;如果delay为0, 就代表立刻插入到事件队列。

setInterval是延迟delay毫秒后, 看看事件队列中是否存在还没有执行的回调函数, 如果还存在, 就不要再往事件队列中添加回调函数了。

定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。所以真正何时执行代码的时间是不能保证的，取决于何时被主线程的事件循环取到，并执行。
```js
// 模拟代码 
// window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。
// 看来每次只执行一次，就是下一帧一次，大概16.7 ms 间隔执行一次
function setTimeout2 (cb, delay) { 
    let startTime = Date.now() 
    loop() 
   
    function loop () { 
      const now = Date.now() 
      if (now - startTime >= delay) { 
        cb(); 
        return; 
      } 
      requestAnimationFrame(loop) 
    } 
}
```
```js
// setTimeout系统时间补偿
const speed = 500
let counter = 1
let start = new Date().getTime(); 
    
function instance() { 
    let real = (counter * speed);
    let ideal = (new Date().getTime() - start); 
    counter++; 
    const diff = (ideal - real); 
    window.setTimeout(function() { instance(); }, (speed - diff)); // 通过系统时间进行修复 
}; 
setTimeout(function() { instance(); }, speed); 
```
## 实现图片懒加载？
```js
function isVisible(img) {
  // 判断是否在可视区域，并返回true或false
  const imgRect = img.getBoundingClientRect() // getBoundingClientRect 获取图片的动态信息
  return imgRect.bottom > 0 && imgRect.top < window.innerHeight // 不然就在上面或下面
}
const images = [...document.querySelectorAll('img')]
// 利用循环判断每张图片是否属于可视区域
function lazyLoad(){
    for (let i = 0; i < images.length; i++) {
      if (isVisible(images[i])) {
        img.setAttribute('src', img.getAttribute('data-src'))
      }
    }
}
lazyLoad()
```
```js
// 利用Intersection Observer实现
window.addEventListener('scroll', lazyLoad)
const observer = new IntersectionObserver(callback)
// 给每一个图片绑定观察方法
imagess.forEach(img => {
  // 图片进入视野+离开视野时会触发callback回调函数
  observer.observe(img)
})
// callback 接收的参数为带有监听所有图片交叉属性的集合
const callback = (imgArr) => {
  console.log('视图交叉时触发，离开交叉时也触发', imgArr) 
  imgArr.forEach(e => {
    // 判断是否在视野区域
    if (e.isIntersecting) {
      e.target.src = e.target.dataset.src
      // 取消监听，避免重复加载同一张图片
      observer.unobserve(e.target)
    }
  })
}
```
## 输出今天的日期，以 YYYY-MM-DD 的方式，比如今天是2014年9月26日，则输出 2014-09-26 
```js
var d = new Date();
// 获取年，getFullYear()返回 4 位的数字
var year = d.getFullYear();
// 获取月，月份比较特殊，0 是 1 月，11 是 12 月
var month = d.getMonth() + 1;
// 变成两位
month = month < 10 ? '0' + month : month;
// 获取日
var day = d.getDate();
day = day < 10 ? '0' + day : day;
alert(year + '-' + month + '-' + day);
```
## 请将一个 URL 的 search 部分参数与值转换成一个 json 对象？
## 如何获取对象 a 拥有的所有属性（可枚举的、不可枚举的，不包括继承来的属性）？
## 统计 1 到 400 亿之间的自然数中含有多少个 1？比如 1-21 中，有 1、10、11、
21 这四个自然数有 5 个 1 *