# 网络与浏览器
## 什么是同源策略以及跨源资源共享（CORS）？
同源策略是浏览器只允许当前网页与同一源（即同一域/协议/端口）下的其他资源进行交互，是浏览器的一种安全机制，用于保护用户的安全和隐私。

CORS全称为Cross-Origin Resource Sharing，跨源资源共享，通过在HTTP header附加信息，告诉浏览器准许运行在一个源上的Web应用访问位于另一不同源选定的资源。例如A网站的ajax请求在http header中添加上`Origin: http://A.com`字段后发送到B网站的服务器，
B网站的服务器接收后，看到请求头中有Origin字段，明白了这是来自A源的CORS跨域请求，在返回正常响应数据时，在响应头会添加例如`Access-Control-Allow-Origin: *`这样的字段，
当浏览器接收到该响应后，它会查看响应头中的Access-Control-Allow-Origin字段是否包含本域(A.com，星号表示全匹配)，如果包含，则将该响应交给发出该ajax请求的js脚本，否则浏览器拒绝该响应。
> * 服务器是永远都会返回正常响应的，而这个响应最终能不能交到ajax调用方的手上（能否跨域成功），是浏览器在做决定。
> * 跨源访问时，ajax脚本只能从响应中获取一些最基本的http头，其中不包括Set-Cookie（被浏览器拦截了）。此时需要服务器主动将该字段暴露出去。在响应头中添加`Access-Control-Expose-Headers: 'Set-Cookie'`代表服务器允许其他源获取Set-Cookie头部字段，此时浏览器才会把该信息安心地交给脚本。
## get/post 请求的区别？
* 在语义上，get请求用于获取数据，是幂等的，多次相同的GET请求不能对服务器的状态有影响，因此get请求可以被缓存以提高性能；post请求用于提交数据，不是幂等的，会对服务器状态产生影响，不能缓存。
* get传参是通过地址栏URL传递，把请求的数据在URL后通过?连接，通过&进行参数分割，只支持ASCII字符，只能URL编码；post将参数存放在HTTP的包体内，没有字符类型限制，有多种编码格式。
* get请求的长度受URL限制，一般在2KB到8KB左右，post请求长度受浏览器和服务器限制，一般在2MB到10MB左右。
* post请求往往不是简单请求，通常会触发一次opinions请求，用于CORS预检，检查你是否有权限去进行此次的POST请求。
## http的状态码说几个？
> 1xx(临时响应)2xx(成功)3xx(重定向)4xx(请求错误)5xx(服务器错误)

* 100：请求者应当继续提出请求。
* 101：Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议。
* 200：正确的请求返回正确的结果。
* 201：表示资源被正确的创建。比如说，我们 POST 用户名、密码正确创建了一个用户就可以返回 201。
* 202：请求是正确的，但是结果正在处理中，这时候客户端可以通过轮询等机制继续请求。
* 300：请求成功，但结果有多种选择。相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择。
* 301：请求成功，但是资源被永久转移。返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替。
* 303：使用 GET 来访问新的地址来获取资源。
* 304：请求的资源并没有被修改过。服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源
* 400：请求出现错误，比如请求头不对等。
* 401：没有提供认证信息。请求的时候没有带上 Token 等。
* 402：为以后需要所保留的状态码。保留，将来使用。
* 403：请求的资源不允许访问。就是说没有权限。
* 404：请求的内容不存在。
* 500：服务器错误。
* 501：请求还没有被实现。服务器不支持请求的功能，无法完成请求。
## Cookie、localStorage、sessionStorage、IndexedDB的区别？
* Cookie有过期时间，Cookie的信息会在http请求的时候携带到服务器。
* localStorage是永久存储，最大限制一般为5-10MB，所有数据都将作为字符串存储。
* sessionStorage是会话存储，浏览器关闭就会消失。
* IndexedDB是前端数据库，能存储几百MB的数据，api比较复杂。
## TCP与UDP是什么？
* TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，使用三次握手协议建立连接、四次挥手断开连接。
    * 三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的：
        * 第一次握手（客户端发送 SYN 报文给服务器，服务器接收该报文）：客户端什么都不能确认；服务器确认了对方发送正常，自己接收正常
        * 第二次握手（服务器响应 SYN 报文给客户端，客户端接收该报文）：客户端确认了：自己发送、接收正常，对方发送、接收正常；服务器确认了：对方发送正常，自己接收正常
        * 第三次握手（客户端发送 ACK 报文给服务器）：客户端确认了：自己发送、接收正常，对方发送、接收正常；服务器确认了：自己发送、接收正常，对方发送、接收正常
    > 服务器收到客户端第一次握手信息之后，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为半连接队列。同样，在关闭时，
        TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力，这叫半关闭特性。
    * 终止一个 TCP 连接要经过四次挥手。这是由于 TCP 的半关闭（half-close）特性造成的，因此需要同时关闭客户端和服务端，客户端或服务端均可主动发起挥手动作。例如客户端先发起的关闭请求：
        * 第一次挥手客户端发送给服务端一个信息，客户端停止发送业务数据
        * 第二次挥手服务端发送给客户端一个信息，客户端接受到后，客户端到服务端的连接释放，此时的 TCP 处于半关闭状态
        * 第三次挥手

* UDP是一种无连接的，不可靠的，基于报文的传输层通信协议，能够多播广播。
## 强制缓存和协商缓存有什么区别？
浏览器缓存(Brower Caching)是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。
* 强制缓存：根据Expires（response header里的过期时间）判断，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存，并不会向服务端发起请求，展示为200状态。
* 协商缓存：客户端向服务端发送带有If-None-Match和If-Modified-Since的请求进行协商判断，如果资源没有变化继续使用本地缓存，记录为304状态；如果资源发生变化，服务端响应数据，记录为200状态。

```js filename="demo.js" {3} copy
let a = 1;

console.log(a);
```

## Component

import { useState } from 'react'

{/* Import CSS modules */}
import styles from '../components/counters.module.css'

export const Counter = () => {
  const [count, setCount] = useState(0);
  return (
    <div>
      <button onClick={() => setCount(count + 1)} className={styles.counter}>Clicked {count} times</button>
    </div>
  );
};

<Counter/>

## External Component

import Counters from '../components/counters'

<Counters />
