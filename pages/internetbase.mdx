# 初级
## 什么是同源策略以及跨源资源共享（CORS）？
同源策略，是浏览器的一个安全机制，用于限制文档和脚本与来自另一个源的资源的交互。
这个机制主要用于隔离潜在的有害文档，保护用户的安全和隐私。

跨源资源共享是用于在不同的源中获取资源的一个机制。
对于简单请求，在头信息之中增加一个Origin字段即可实现跨域能力。
对于非简单请求，会在正式通信之前有一次预检请求，得到肯定答复后，浏览器才会发出正式请求。

> 简单请求是满足两个条件：`HEAD, GET, POST`方法之一；头信息是有限的指定的几个字段。其他的都是非简单请求。

## 讲一讲什么是URL编码？

Url编码通常也被称为百分号编码，使用%百分号加上该字节的十六进制形式组成编码。Url编码默认使用的字符集是US-ASCII[ˈæski]。
对于Unicode字符，则使用%百分号加上该字节的utf-8字节组成编码。

URL中有些字符会引起歧义。例如URL参数字符串中如果包含”&”或者”%”就会造成服务器解析错误，所以需要对其进行编码。

encodeURI() 函数用于将字符串作为 URI 进行编码。该方法的目的是对目标URI进行编码使之成为一个合格的URI。

encodeURIComponent() 函数用于将字符串作为 URI 参数的值进行编码。因此encodeURIComponent() 函数还必须转义用于分隔 URI 各个部分的标点符号，以防止歧义。

## 强制缓存和协商缓存有什么区别？
浏览器缓存(Brower Caching)是浏览器将用户最近请求过的文档存储在本地磁盘里，当访问者再次访问时，浏览器就可以直接从本地磁盘加载文档。
* 强制缓存：根据响应头里的过期时间Expires判断，当浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存并返回，并不会向服务端发起请求，记录为200状态。
* 协商缓存：客户端向服务端发送请求进行协商判断，如果资源没有变化继续使用本地缓存，记录为304状态；如果资源发生变化，服务端响应数据，记录为200状态。

## 如何清除缓存，强制刷新？
* 在后端或者请求头上加缓存清除的字段，即`add_header Cache-Control no-store;`字段。
* 在前端页面可以加`<META HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate"> `标签。
* 在url上加随机字符串。

## get/post 请求的区别？
* 在语义上，get请求用于获取数据，是幂等的，多次相同的GET请求不能对服务器的状态有影响，因此get请求可以被缓存以提高性能；
post请求用于提交数据，不是幂等的，会对服务器状态产生影响，不能缓存。
* 在参数上，get传参是通过地址栏URL传递，只支持ASCII字符，只能URL编码，长度最多2KB左右；
post将参数存放在HTTP的包体内，没有字符类型限制，有多种编码格式，长度最多在10MB左右。

## 讲一讲https以及证书（SSL）
* https是密文传输，通过非对称密钥，数字证书等方式完成数据加密传输。解决了http明文传输易受到中间人攻击的问题。
* 非对称加密是指一对不同的密钥，用其中一个密钥加密的密文，只能被另一个密钥解开，公开的密钥称为公钥，不公开的称为私钥。
能解决对称加密被中间人获取到密钥的问题，但仍不能解决中间人在中间代理信息的问题，即中间人获取到公钥后，对两端用自己的公钥私钥代理信息。
* 证书则能解决中间人代理信息的问题
    1. 首先服务端使用摘要算法（例如MD5）将证书明文（例如域名，服务端公钥）生成摘要，然后送给CA权威机构。
    2. CA机构将摘要用CA机构自己的私钥进行加密，得出来的叫签名，然后附在证书上。
    3. 证书被发送到客户端，客户端通过同样的摘要算法对证书明文计算摘要，然后用CA机构的公钥解开签名得到解密的摘要，
两者比对相同，则证明证书没有篡改，证书上服务端的公钥是该服务端生成的公钥，因此客户端拿到了服务端的公钥。
* 浏览器向服务器发起Https请求的流程如下：
    1. 首先浏览器向服务器发起请求。
    2. 服务器将证书机构颁发给自己的证书传递给浏览器。
    3. 浏览器从本地安装的根证书中找到证书机构的公钥，用公钥来验签证书的正确性，确保是证书机构用私钥签名的合法证书，从而拿到了服务器公钥。
    4. 浏览器随机生成一个对称秘钥key，用证书中的服务器公钥加密这个key，再传输给服务器。
    5. 服务器用私钥解密后取出对称秘钥key，并用该key加密确认内容返回给客户端，告知可以开始通信。
    6. 浏览器与服务器开始采用该key进行加密通信。
## http的状态码说几个？
> 1xx(临时响应)2xx(请求成功)3xx(重定向)4xx(请求错误)5xx(服务器错误)

* 100：请求者应当继续提出请求。
* 101：切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议。
* 200：正确的请求返回正确的结果。
* 201：表示资源被正确的创建。比如说，我们 POST 用户名、密码正确创建了一个用户就可以返回 201。
* 202：请求是正确的，但是结果正在处理中。这时候客户端可以通过轮询等机制继续请求。
* 300：请求成功，但结果有多种选择。相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择。
* 301：请求成功，但是资源被永久转移。返回信息会包括新的 URI，浏览器会自动定向到新 URI。今后任何新的请求都应使用新的 URI 代替。
* 304：请求的资源并没有被修改过。服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源。
* 400：请求出现错误，比如请求头不对等。
* 401：没有提供认证信息。请求的时候没有带上 Token 等。
* 402：为以后需要所保留的状态码。保留，将来使用。
* 403：请求的资源不允许访问。就是说没有权限。
* 404：请求的内容不存在。
* 500：服务器错误。
* 501：请求还没有被实现。服务器不支持请求的功能，无法完成请求。

## Cookie、localStorage、sessionStorage、IndexedDB的区别？
* Cookie有过期时间，Cookie的信息会在http请求的时候携带到服务器。
* sessionStorage是会话存储，浏览器关闭就会消失。
* localStorage是永久存储，最大限制一般为5-10MB，所有数据都将作为字符串存储。
* IndexedDB是前端数据库，能存储几百MB的数据，api比较复杂。

## TCP与UDP是什么？
* UDP是一种无连接的，不可靠的，基于报文的传输层通信协议，能够多播广播。
* TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，使用三次握手协议建立连接、四次挥手断开连接。
    * 三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的：
        * 第一次握手（客户端发送 SYN 报文给服务器，服务器接收该报文）：客户端什么都不能确认；服务器确认了对方发送正常，自己接收正常
        * 第二次握手（服务器响应 SYN 报文给客户端，客户端接收该报文）：客户端确认了：自己发送、接收正常，对方发送、接收正常；服务器确认了：对方发送正常，自己接收正常
        * 第三次握手（客户端发送 ACK 报文给服务器）：客户端确认了：自己发送、接收正常，对方发送、接收正常；服务器确认了：自己发送、接收正常，对方发送、接收正常
    > 服务器收到客户端第一次握手信息之后，此时双方还没有完全建立其连接，服务器会把这种状态下的请求连接放在一个队列里，我们把这种队列称之为半连接队列。同样，在关闭时，
        TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力，这叫半关闭特性。
    * 终止一个 TCP 连接要经过四次挥手。这是由于 TCP 的半关闭（half-close）特性造成的，因此需要同时关闭客户端和服务端，双方都应该知道对方已关闭，客户端或服务端均可主动发起挥手动作。例如客户端先发起的关闭请求：
        * 第一次挥手客户端发送给服务端一个信息，客户端关闭TCP链接，但并不知道服务端关闭，因此处于等待状态1。
        * 第二次挥手服务端发送给客户端一个信息，客户端接受到后知道服务端已经知道自己打算关闭了，于是客户端到服务端的连接释放，客户端处于等待状态2，此时的 TCP 处于半关闭状态，服务端仍可发送数据到客户端。
        * 第三次挥手服务端发送给客户端一个信息，表示服务端也想关闭连接，此时服务端处于一种等待状态，客户端接收到后处于等待状态3
        * 第四次挥手客户端发送给服务端一个信息，服务端收到后关闭连接，

