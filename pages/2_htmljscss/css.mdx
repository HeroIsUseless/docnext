# 高频
## 水平居中的方法，垂直居中的方法？
* 内联元素居中
    * 通过`text-align: center;`实现水平居中，通过`line-height = height`实现垂直居中。
* 块级元素居中
    * 通过flex的`justify-content`和`align-item`实现水平/垂直居中。
    * 设置`margin: auto`实现水平/垂直居中。如果只是水平居中则使用`margin:0 atuo;`。
    * 设置`position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);`实现水平/垂直居中。
    * 设置`position: absolute; top: calc(50% - height/2px); left: (50% - width/2px);`实现水平/垂直居中，但需要知道元素宽高
## 使元素消失的方法有哪些？
1. `display:none;`能将元素隐藏起来，并且会改变页面布局，不会触发该元素已经绑定的事件。
2. `visibility:hidden;`能将该元素隐藏起来，不会改变页面布局仍占据原有空间，但不会触发该元素已经绑定的事件。
3. `opacity:0;`能将该元素隐藏起来，仍占据原有空间，并且会触发该元素已经绑定的事件。
4. `position:absolute;top:-1000px;left:-1000px;`这个方法是通过将left和top的值设的很大，让元素定位到浏览器外面。不占据空间，不能点击。
> opacity会继承父元素的opacity 属性，而RGBA设置的元素的后代元素不会继承不透明属性。简单来说就是opacity作用于元素和元素所有内容的透明。
## 页面导入样式时，使用link和@import有什么区别？
* link是html标签，页面载入时同时加载，除了加载css外，还可以定义RSS等其他事务，无兼容问题；
* @import属于CSS范畴，在页面完全加载以后加载，只能加载CSS；
* link方式的样式的权重高于@import的权重
## 文字换行有什么办法？
* 使用`word-wrap`属性，可以控制文本的换行方式。
    * normal: 只在合适的时候换行，不会在单词内部换行，如果一个单词长度超出了容器长度，单词将超出边界；
    * break-word: 比容器长的单词将在单词内部换行；
* word-break属性关注单词内的换行方式，一般在设置`word-wrap: break-word`时使用，它有以下几种取值：
    * normal: 默认属性值，不允许在单词中间截断。
    * break-all: 表示都全部单词内换行，即便这个单词并没有长得超出了边界。处理中文则不会生效。
    * keep-all: 指CJK（中/日、韩）文本超出区域不断行，但会在标点出折行。
* white-space是用来控制文本中空格和换行的属性。
    * normal:默认属性值，表示文本中连续多个空格换行都会被合并为一个空格；
    * nowrap:表示文本不会被自动换行；
    * pre:表示文本中连续多个空格换行都会被保留，不会自动换行。
    * pre-wrap:表示文本中连续多个空格换行会被保留，超出容器宽度时，会发生换行。
    * pre-line:表示文本中连续多个空格会被合并成一个空格，但是换行会被保留，会自动换行。
> 如果文字不换行，可以用`text-overflow:ellipsis;`显示省略符号来代表被修剪的文本。
## 盒模型是什么？
页面中的所有元素都可以看成一个盒子，由4个属性组成的（content（内容），padding（内边距），border（边框），margin（外边距）），
有标准盒模型和ie盒模型，在标准盒模型中，元素的宽度和高度等于内容区域的宽度和高度，
在ie盒模型中，元素的宽度和高度定义为内容区域的宽度和高度加上内边距和边框的宽度和高度。
用box-sizing属性来控制元素使用哪种盒模型。box-sizing属性有两个值：content-box和border-box。content-box是标准盒模型，border-box是IE盒模型。默认值是content-box。
<div style={{display: 'flex'}}>
<div style={{boxSizing: 'content-box', width: '150px', height: '100px', padding: '20px', border: '10px solid black', margin: '10px', fontSize: '12px'}}><span>box-sizing: content-box</span></div>
<div style={{boxSizing: 'border-box', width: '150px', height: '100px', padding: '20px', border: '10px solid black', margin: '10px', fontSize: '12px'}}><span>box-sizing: border-box</span></div>
</div>
## 讲一讲css3新特点？
> 2001年5月23日W3C完成了CSS3的工作草案（但至今没有定稿），主要包括盒子模型、列表模块、超链接方式、语言模块、背景和边框、文字特效、多栏布局等模块。
* 盒模型
* 新增文字属性
    * word-wrap: normal|break-word 使用浏览器的默认换行或者允许单词内换行
    * text-overflow: clip|ellipsis 设置当前行超过指定容器的边界时如何显示，修剪文本或者显示省略符号来代表被修剪的文本
* 新增颜色透明度/渐变
* 新增背景属性`background-size`，`background-origin`，`background-break`，`background-clip`
* 新增边框属性`border-radius`，`border-image`，`box-shadow`
* transform 转换
* transition 过渡，多个属性之间用逗号进行分隔，必须规定过渡效果，持续时间两个内容，语法为：`transition: CSS属性, 花费时间, 效果曲线（默认ease）, 延迟时间（默认0）`
* animation 动画
* 新增弹性布局，网格布局，多列布局
* 媒体查询
* 添加了伪类/伪元素/多重/属性选择器，例如`:hover`，`::before ::after ::selection first-line/letter`，`ele1, ele2`，`[attr=value]`。
## css的渲染优先级？
* 选择器都有一个权值，权值越大越优先
    * 内联样式表的权值最高 1000
    * ID 选择器的权值为 100
    * Class 类选择器的权值为 10
    * HTML 标签选择器的权值为 1
* 当权值相等时，后出现的样式表设置要优于先出现的样式表设置
* 网页编写者设置的CSS 样式会覆盖浏览器所设置的样式，后来指定的CSS 样式会覆盖继承的CSS 样式，后面指定的CSS样式会覆盖之前指定的CSS样式，后定义class会覆盖先定义的class
* 在同一组属性设置中标有“!important”规则的优先级最大
* 先写的div会被后写的div覆盖住，点击不会穿透到下面的兄弟节点，你可以用`document.elementsFromPoint(event.clientX, event.clientY);`

## clientHeight,scrollHeight,offsetHeight ,以及scrollTop, offsetTop,clientTop的区别？

## BFC是什么？
BFC即块级格式化上下文(Block Formatting Contexts)，具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。

BFC 特性及应用
* 避免外边距重叠，如果两个相邻元素在不同的BFC中，就能避免外边距折叠。但属于同一个BFC的两个相邻元素的外边距仍会发生重叠。
* 可以包含浮动的元素，其高度能被其内部的浮动元素撑开，因此可以清除浮动。

只要元素满足下面任一条件即可触发 BFC 特性：
* html根标签
* `float: left|right`
* `overflow: hidden|auto|scroll`，就是不能为visible
* `display: table-cell|table-caption|inline-block|inline-flex|flex`
*  `position: absolute|fixed`
<div style={{overflow: 'hidden', width: '300px', backgroundColor: 'rgba(255, 0,0,0.5)'}}>
    <div style={{margin: '20px', width: '50px', height: '50px', backgroundColor: 'rgba(0, 0,255,0.5)'}}></div>
    <div style={{margin: '20px', width: '50px', height: '50px', backgroundColor: 'rgba(0, 0,255,0.5)'}}></div>
    <div style={{margin: '20px', width: '50px', height: '50px', backgroundColor: 'rgba(0, 0,255,0.5)'}}></div>
</div>
## 了解float浮动布局吗？
float 属性早期用于图文混排, 实现文字环绕的效果。

元素一旦浮动后（即`float: left`），脱离文档流，朝着向左或向右方向移动，不占据原来的位置，但会影响其他元素的文本。
> 当父元素一行内显示不下所有浮动元素时，显示不下的会会换行。被挤落下来的元素，会躲开被上一层元素占据的最大高度。

<div style={{width: '400px', height: '300px', border: '2px solid black'}}>
<div style={{width: '100px', height: '90px', background: 'rgba(255, 0,0, 0.5)'}}>div1</div>
<div style={{float: 'left', width: '200px', height: '150px', background: 'rgba(0, 255,0, 0.5)', fontSize: '13px'}}>内部文本被影响，这种特性常常被用于实现网页中的多列布局、图像与文本的并排显示等效果。div2(f)</div>
<div style={{float: 'left', width: '100px', height: '90px', background: 'rgba(123, 123,123, 0.5)'}}>div3(f)</div>
<span style={{background: 'rgba(0, 123,123, 0.5)'}}>span3.1</span>
<div style={{width: '100px', height: '90px', background: 'rgba(0, 0,255, 0.5)'}}>div4</div>
<div style={{width: '100px', height: '90px', background: 'rgba(123, 123,123, 0.5)'}}>div5</div>
<div style={{float: 'right', width: '100px', height: '90px', background: 'rgba(0, 0,123, 0.5)'}}>div6(f)</div>
</div>

## 常见选择器？
* 星号`*`定义所有元素，建议绝对不要在最终的产品代码中使用。因为会给浏览器增加大量不必要的负荷。
* 星形`*`也可以用于子元素选择器，这段代码会定义`#container div`所有子元素的样式。
```
#container * {
 border: 1px solid black;
}
```
* X Y 后代选择器。假如说你只想选择无序列表里的链接，而不是所有的链接，这种情况下你就应该使用后代选择器。
```
li a {
text-decoration: none;
}
```
* X + Y 邻近元素选择器，只会选中紧接在另一个元素后的元素。只有每个ul后面的第一个段落是红色的。
```
ul + p {
 color: red;
}
```
* X > Y 只会选中直接后代。X Y会选中所有子孙后代。
```
div#container > ul {
    border: 1px solid black;
}
```
* X ~ Y 兄弟节点，只要在ul后的p兄弟元素都会被选中。
```
ul ~ p {
 color: red;
}
```
* X[title] 带有title属性的链接标签才会被匹配。没有title属性的标签不会受到影响。
```
a[title] {
 color: green;
}
```
* X[href="foo"] 定义了所以指向http://net.tutsplus.com的链接都是nettuts品牌的绿色。其他的链接不受影响。
```
a[href="http://net.tutsplus.com"] {
color: #1f6053; /* nettuts green */
}
```
* X:after 伪类before和after属于高级用法。几乎每一天都有人找到高效而有创意的新用法。这两个伪类可以在元素前面和后面添加内容。
> 根据CSS3选择器规范，语法上你应该使用双冒号来::来指定伪类。然而，为了兼容多数浏览器，单冒号也被承认。实际上，在目前的情况下，使用单冒号的选择是明智的。
* X:hover 用户交互伪类
* X:not(selector) 否定伪类非常有用。比如，我希望选中所有的div元素，除了一个id为container的div。
```
div:not(#container) {
 color: blue;
}
```
* X::pseudoElement 我们可以使用伪元素（用::表示）来定义某些片段元素，比如第一行或第一个字母。要记住的是这只能用于块状（block）元素。
```
p::first-line {
 font-weight: bold;
 font-size: 1.2em;
}
```
* X:nth-child(n) nth-child指序列里的第n个元素，从1数起。如果你想匹配列表里的第二个元素，可以使用li:nth-child(2)。
我们甚至可以使用这种方法来选择一系列的子元素。比如li:nth-child(4n)可以选择排在4的倍数的元素。
nth-last-child这个技巧跟上面的一样，但是从集合的最后一个数起。
```
li:nth-child(3) {
 color: red;
}
```
* X:first-child 可以用于选中母元素的第一个子元素，常常用于去掉第一个或最后一个元素的边框。last-child是first-child的反面，可以匹配最后一个子元素。


## 清除浮动的方法？
在文档流中，父元素的高度默认是由子元素撑开的。当父元素如果不设置高度，而且父元素内所有的子元素都设置了浮动，没有了子元素来撑起父元素的高度，
父元素的高度将会是0，引起高度坍塌。导致页面布局混乱。
<div style={{background: 'rgba(0,255,0,0.5)'}}>
    <div style={{float: 'left', width: '100px', height: '100px', background: 'rgba(255,0,0,0.5)'}}></div>
</div>
浮动元素会脱离正常的文档流，可能导致父元素的高度塌陷，然后会影响下一个元素的文本（本段预期应在下一行展示），清除浮动就是这个问题。
<div style={{clear: 'both'}}></div>
* 转成BFC，其高度能被其内部的浮动元素撑开。
* 在浮动元素后面添加一个元素，并为其添加`clear: both;`样式。这个元素可以是实际的DOM元素，也可以是一个看不见的元素。缺点是它需要在你的HTML中添加额外的元素。
* 使用::after或::before伪元素并为其添加`clear: both;`样式来清除浮动。这种方法的优点是不需要在HTML中添加额外的元素，但缺点是它可能会影响到其他样式（如背景和边框的渲染）。
## 外边距合并是什么意思？
当两个外边距相邻时，它们会合并为较大的那一个。 合并会发生在普通文档流的相邻块级元素的垂直外边距上。阻止外边距合并的方法有：
* 使用内边距或透明边框代替外边距
* 触发BCF（但两个相邻的块级盒子的垂直外边距会触发重叠）

## width=device-width以及1rem、1em的含义？

视口（viewport），指的是浏览器窗口中用来显示网页的区域。
以浏览器来说，就是浏览器的窗口内容区域（除去标题栏，菜单栏，地址栏，状态栏等等浏览器的“周边”的东西）。
视口表现得像是之上的一个块元素，它限制并确定的宽度，但却不属于html结构，不能被设置样式。
而且，任何时候，视口的尺寸都会随着浏览器窗口的大小变化而变化。桌面电脑中的视口，就是这样的一个概念。

相比桌面电脑，在手机上浏览网页，最大的差异在于屏幕尺寸。
电脑端的页面到手机上，很容易出现水土不服（一些流体布局的网页会在过窄的视口中变得一团乱），
为了让用户在手机上也获得最佳的网页浏览体验，应该让视口更宽，超越屏幕的宽度。
所以，在手机浏览器中，视口被划分为了两个：可见视口（visual viewport）和布局视口（layout viewport）。

* 可见视口是指当前在手机屏幕上显示的部分。
* 和可见视口不同，布局视口则是整个页面的窗口，用于元素布局和尺寸计算（比如百分比的宽度值），而且比可见视口明显要更宽。
无论你缩放，或者滑动页面，甚至翻转手机屏幕，布局视口始终不变。
布局视口的宽度是由手机浏览器定义的，随浏览器不同而不同。比如Safari是980px，Android Webkit是800px。这都远比屏幕宽度值要大。

手机中的布局视口是可以更改的。你一定在很多移动版网页中见到过下边这个标签元素。
```html
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
```
这其中有一句width=device-width，它的意思是，把手机浏览器的布局视口的宽度，更改为当前设备的宽度，也就是等于可见视口。

逻辑像素才是px，设备像素是dp。我们得知iphone5的尺寸为4英寸，设备分辨率为640dp*1136dp，手机基本上都是视网膜屏，dpr=2。 
那么逻辑像素就是320px*568px。

但设置width=device-width后，ios中默认的布局viewport是980px。

* Visual ViewPort（可视窗口）就是手机屏幕的可视区域，可以通过横竖滑动条或者放大缩小预览网页的窗口。
（其大小可通过window.innerWidth获取）
* Layout ViewPort（布局窗口）主要是用来展示原始页面，其窗口的分辨率跟PC显示器分辨率相接近。
（其初始页面宽度与不同设备浏览器相关，其大小可通过document.documentElement.clientWidth获取）

我们将Visual ViewPort放大到和Layout ViewPort相同的宽度。整个页面就可以显示在手机屏幕上了，
但是其实这还是有问题的（缩放到跟Layout ViewPort原始宽度一样的话，页面元素也会按照比例缩放导致文字看不清）。
因此还需要禁止其自动缩放，办法就是`initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no`

比如说ios中默认的布局viewport是980px，手机是640dp，dpr是2，逻辑像素320px，`width=device-width`后，
980px映射到320px，所以css中的320px只是屏幕上1/3不到。

那么我们怎么搞定设计图的尺寸与实际尺寸一致呢？这就需要换算了，设计图的宽度往往750px，转换参数是980/750就可以了。

如果不设置`width=device-width`，那么就没有映射，手机屏幕只显示原网页宽度的1/3不到。

* em，是一个相对单位。相对于当前对象内文本的font-size，如果当前文本的字体尺寸没有设置，则相对于浏览器的默认字体尺寸。即1em=16px。
* rem，是一个相对单位。是相对HTML根元素，通过rem既可以做到只修改根元素就可以成比例的调整所有字体。

## 手机端的线比较细？
* viewport的问题
* devicePixelRatio的问题
* PPI（pixels per inch）是指每英寸的像素数目，常用于度量计算机显示设备像素密度。
* DPI（dots per inch）是指每英寸数码印刷的点数，用于度量印刷行业的空间点的密度。

CSS 像素是编程中的概念，用于逻辑上衡量像素的单位。
* 物理分辨率是显示器的固有参数，不能调节，一般是指屏幕的最高可显示的像素数。
* 显示器分辨率就是操作系统设定的分辨率。在显示器分辨率和物理分辨率一致时，显示效果才是最佳的，一般推荐设置的分辨率就是物理分辨率。系统设置分辨率生效是通过算法进行了转换。
* 设备独立像素也叫逻辑像素，是一种基于计算机坐标系统的物理测量单位，应用程序将独立像素告诉系统，系统再将设备独立像素转换为物理像素。
我们在样式表中使用的px（独立像素）单位其实并不一定代表着实际的一个像素（物理像素）。
如果切了一张10像素宽高的图放在devicePixelRatio为2的屏幕中，设置宽高为10px，实际上就是在20像素宽高的区域中放了一张10像素的图片，
而图片被拉长为20像素，这样就糊了。如果要完美显示得放一张20像素宽高的图。

所以一般来说，图不一定偏大，但是一定是偏模糊的，因为四个手机像素的面积往往比一个电脑像素的面积大。
如果小，那么实际上不算糊。如果是特大屏，那当然也是糊的，但跟人的距离也有一定关系，所以特大屏也不算糊。
canvas放大的话，会有智能算法调整每个像素的颜色，所以会糊，因此必须让canvas的dpr为1才行。
而在ps上，就没有这个问题，它保留了像素，在完全两倍的情况下，像素点放大成了4个，简单放大，没有智能算法处理。

而在电脑屏幕或者canvas上，放大两倍并不是简单放大，而是通过线性插值去填充多余的像素。

如果用邻近像素采样，这样图像看起来就好像是由非常大的像素简单组成的。或者叫整数缩放，那么还是一样清晰的，但必须是整数倍。
放大的位图就变成了马赛克。
非整数倍的用双线性插值，那么这就是模糊的源头。目前canvas还不怎么支持更改插值函数，默认双线性插值。
放大的位图就变模糊了。

还有一种办法是超采样，对于不足2倍的，先按照2倍放大，然后再采样缩小到指定比例，这样做比双线性插值要清晰一些。
而位图部分会变得模糊。

缩放的目的就是让软件在不同像素大小下，看起来大小都差不多一样。因为人眼距离这些屏幕的距离差不多一样。
如果离人眼近的，比如说手机，那么展示的东西小一点，其实没什么关系，小一点反而更好。

高分屏，如果dpr为1，那么同样清晰的，但像素小很多，展示的东西也会小很多。

一句话就是，如果是整数倍分辨率+邻近像素采样会清晰，其他分辨率都会采用双线性采样导致变模糊。

为什么要用双线性采样，因为它生成的图片比邻近采样质量高，邻近采样会更清晰一点，但全是颗粒感和锯齿，不代表质量高。一般用于ps这种修图软件用。

window.devicePixelRatio（dpr） ，它是设备上物理像素和设备独立像素（device-independent pixel，dips，dp）比值。
可以通过重写 window.devicePixelRatio来更改此属性，如,：window.devicePixelRatio = 2。
所谓的一倍屏、二倍屏（Retina）、三倍屏，指的是设备以多少物理像素来显示一个CSS像素，也就是说，
多倍屏以更多更精细的物理像素点来显示一个CSS像素点，在普通屏幕下1个CSS像素对应1个物理像素，
而在Retina屏幕下，1个CSS像素对应的却是4个物理像素。
现在主流的智能手机devicePixelRatio大部分为2，一部分为1.5，3的比较少，1的则更少（PC为1）。

如果一个 canvas 在视网膜屏幕上可能显得太模糊。使用  window.devicePixelRatio 添加额外的像素密度可以更清晰的显示图像。

* 双线性插值：大家实际只需要知道是通过周围四个点来算出一个点即可。
* 双三次插值：利用周围16个像素点计算出一个像素点的值。其实依旧是对两个轴的操作。其本质上和双线性插值没有区别，只是插值公式更加复杂而已。
* 

在用户不参与的情况下，我们不能靠程序在网页上获取到准确的浏览器物理长度 1 厘米。

# 低频
## 动画？
## 无样式内容闪烁（FOUC）Flash of Unstyle Content 如何解决？
@import导入CSS文件会等到文档加载完后再加载CSS样式表。因此，在页面DOM加载完成到CSS导入完成之间会有一段时间页面上的内容是没有样式的。

解决方法：使用link标签加载CSS样式文件。因为link是顺序加载的，这样页面会等到CSS下载完之后再下载HTML文件，这样先布局好，就不会出现FOUC问题。
## 说说CSS渐变？
CSS3 Gradient 分为 linear-gradient（线性渐变）和 radial-gradient（径向渐变）。

参数：其共有三个参数，第一个参数表示线性渐变的方向，top 是从上到下、left 是从左到右，如果定义成 left top，那就是从左上角到右下角。第二个和第三个参数分别是起点颜色和终点颜色。你还可以在它们之间插入更多的参数，表示多种颜色的渐变。

## css animation怎么用？
@keyframes 规则用来定义动画各个阶段的属性值，类似于 flash 动画中的关键帧，语法格式如下：
```
@keyframes animationName {
    from {
        properties: value;
    }
    percentage {
        properties: value;
    }
    to {
        properties: value;
    }
}
// 或者
@keyframes animationName {
    0% {
        properties: value;
    }
    percentage {
        properties: value;
    }
    100% {
        properties: value;
    }
}
```
* animationName：表示动画的名称；
* from：定义动画的开头，相当于 0%；
* percentage：定义动画的各个阶段，为百分比值，可以添加多个；
* to：定义动画的结尾，相当于 100%；
* properties：不同的样式属性名称，例如 color、left、width 等等。
```
@keyframes ball {
    0% { top: 0px; left: 0px;}
    25% { top: 0px; left: 350px;}
    50% { top: 200px; left: 350px;}
    75% { top: 200px; left: 0px;}
    100% { top: 0px; left: 0px;} 
}
```
动画创建好后，还需要将动画应用到指定的 HTML 元素。要将动画应用到指定的 HTML 元素需要借助 CSS 属性：
animation: animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction animation-fill-mode animation-play-state;
* animation-name：设置需要绑定到元素的动画名称；
* animation-duration：设置完成动画所需要花费的时间，单位为秒或毫秒，默认为 0；
* animation-timing-function：设置动画的速度曲线，默认为 ease（低速开始，低速结束）； linear/ease-in(低速开始)/ease-out/ease-in-out
* animation-fill-mode：设置当动画不播放时（动画播放完或延迟播放时）的状态； none/forwards(保持最后一个关键帧)/backwards延迟用第一个关键帧/both 同时用两者
* animation-delay：设置动画开始之前的延迟时间，默认为 0； 例如2s
* animation-iteration-count：设置动画被播放的次数，默认为 1； infinite表示无限
* animation-direction：设置是否在下一周期逆向播放动画，默认为 normal； 那用处不多了
* animation-play-state：设置动画是正在运行还是暂停，默认是 running；

# 让Chrome支持小于12px 的文字方式有哪些？区别？
Chrome 中文版浏览器会默认设定页面的最小字号是 12px，英文版没有限制，原由 Chrome 团队认为汉字小于 12px 就会增加识别难度。
可以用transform:scale
