## 双问号??与双感叹号!!的含义？

* 如果给定变量值为 null 或者 undefined，则使用双问号后的默认值，否则使用该变量值，而
|| 操作符是如果前面变量是 null undefined 0 false，继续执行后面的赋值，因此，如果不想转译0的时候，可以用双问号。
* 判断某个变量隐式转换的布尔值。第一个 ! 作用于变量，使其转换为布尔类型，并且取反；第二个 ! 再次取反，得到真正的布尔值。

* Pick用于选取某些类型
* omit用于删除某些类型
* keyof用于返回属性名的字面量联合类型
```
type PersonKeys = keyof Person // 'name' | 'age'
```
* in 用于对联合类型进行迭代
```
{[P in PersonKeys]: string}
```
* readonly 不可以对象属性重新赋值
## 手写Partial
```
type MyPartial<T> = {
    [P in keyof T]?: T[P];
}
```
## 手写Pick
```
type MyPick<T, K extends keyof T> = {
    [P in K]: T[P];
};
```
## 条件类型
```
T extends U ? X : Y
type IsNumber<T> = [T] extends [number] ? boolean : string;
```
* 分配性条件类型: 当 T 是一个联合类型（如 A | B | C）时，TypeScript 会将 T 分配到联合类型的每一个成员上，分别进行条件判断。
* 非分配性条件类型: 如果希望避免分配性行为，可以使用 [] 包裹 T，使其成为一个单一的类型，而不是联合类型。
## 手写Exclude 用于从类型 T 中排除掉那些可以分配给类型 U 的部分。
```
type Exclude<T, U> = T extends U ? never : T;
type A = "a" | "b" | "c";
type B = "a" | "b";
type Result = MyExclude<A, B>; // "c"
```
## 手写Omit
```
type MyOmit<T, K extends keyof T> = {
    [P in Exclude<keyof T, K]: T[P];
}
```
