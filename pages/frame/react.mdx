# 初级
## 什么是受控组件和非受控组件？
* 受控组件：只能通过 React 修改数据或状态的组件，就是受控组件；
* 非受控组件：与受控组件相反，如 input, textarea, select, checkbox 等组件，本身控件自己就能控制数据和状态的变更，而且 React 是不知道这些变更的；
* 那么如何将非受控组件改为受控组件呢？那就是把上面的这些纯 html 组件数据或状态的变更，交给 React 来操作
## useState 的传参方式，有什么区别？
useState()的传参有两种方式：纯数据和回调函数。回调函数方式能在参数中获得最新state，多用于异步的情况。
## 为什么在本地开发时，组件会渲染两次？
在 React.StrictMode 模式下，如果用了 useState,usesMemo,useReducer 之类的 Hook，React 会故意渲染两次，为的就是将一些不容易发现的错误容易暴露出来，同时 React.StrictMode 在正式环境中不会重复渲染。
也就是在测试环境的严格模式下，才会渲染两次。
## useEffect()的清除机制是什么？在什么时候执行？
useEffect(callback)的回调函数里，若有返回的函数，这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。

React 会在组件卸载的时候执行清除操作。若组件产生了更新，会先执行上一个的清除函数，然后再运行下一个 effect。
## 了解React的虚拟dom吗？
Virtual DOM 是以对象的方式来描述真实 dom 对象的，在做一些 update 的时候，可以在内存中进行数据比对，
减少对真实 dom 的操作减少浏览器重排重绘的次数，提高程序的性能，虚拟 dom 增加了一层内存运算，然后才操作真实 dom，将数据渲染到页面上。渲染上肯定会慢上一些。
## 什么是合成事件，与原生事件有什么区别？
React 中所有触发的事件，都是自己在其内部封装了一套事件机制。目的是为了实现全浏览器的一致性，抹平不同浏览器之间的差异性。
React 合成事件采用的是事件冒泡机制，当在某具体元素上触发事件时，等冒泡到顶部被挂载事件的那个元素时，才会真正地执行事件。
## key 的作用是什么？
key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。
## 多次执行 useState()，会触发多次更新吗？
在 React18 中，无论是多个 useState()的 hook，还是操作（dispatch）多次的数据。只要他们在同一优先级，React 就会将他们合并到一起操作，最后再更新数据。
这是基于 React18 的批处理机制。React 将多个状态更新分组到一个重新渲染中以获得更好的性能。（将多次 setstate 事件合并）；在 v18 之前只在事件处理函数中实现了批处理，在 v18 中所有更新都将自动批处理，包括 promise 链、setTimeout 等异步代码以及原生事件处理函数；

# 中级
## 如何实现组件的懒加载？
从 16.6.0 开始，React 提供了 lazy 和 Suspense 来实现懒加载。
```js
import React, { lazy, Suspense } from 'react';
const OtherComponent = lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <OtherComponent />
    </Suspense>
  );
}
```
属性fallback表示在加载组件前，渲染的内容。
## 高阶组件（HOC）？
高阶组件通过包裹（wrapped）被传入的 React 组件，经过一系列处理，最终返回一个相对增强（enhanced）的 React 组件，供其他组件调用。
## React 的 diff 过程
React 只对比当前层级的节点，不跨层级进行比较；
根据不同的节点类型，如函数组件节点、类组件节点、普通 fiber 节点、数组节点等，进入不同的处理函数；
前后两个 fiber 节点进行对比，若 type 不一样，直接舍弃掉旧的 fiber 节点，创建新的 fiber 节点；若 key 不一样，则需要根据情况判断，若是单个元素，则直接舍弃掉，创建新的 fiber 节点；若是数字型的元素，则查找是否移动了位置，若没找到，则创建新的节点；若 key 和 type 都一样，则接着往下递归；
若是单个 fiber 节点，则直接返回；若是并列多个元素的 fiber 节点，这里会形成单向链表，然后返回头指针（该链表最前面的那个 fiber 节点）；
通过上面的 diff 对比过程，我们也可以看到，当组件产生比较大的变更时，React 需要做更多的动作，来构建出新的 fiber 树，因此我们在开发过程中，若从性能优化的角度考虑，尤其要注意的是：
节点不要产生大量的越级操作：因为 React 是只进行同层节点的对比，若同一个位置的子节点产生了比较大的变动，则只会舍弃掉之前的 fiber 节点，从而执行创建新 fiber 节点的操作；React 并不会把之前的 fiber 节点移动到另一个位置；相应的，之前的 jsx 节点移动到另一个位置后，在进行前后对比后，同样会执行更多的创建操作；
不修改节点的 key 和 type 类型，如使用随机数做为列表的 key，或从 div 标签改成 p 标签等操作，在 diff 对比过程中，都会直接舍弃掉之前的 fiber 节点及所有的子节点（即使子节点没有变动），然后重新创建出新的 fiber 节点；


# 高级
## React16的fiber架构？
默认情况下，JavaScript 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系，如果 JavaScript 运算持续占用主线程，页面就没法得到及时的更新，
阻塞了浏览器的 UI 渲染，Fiber 架构将更新任务分解成小的、可中断的单元，分批完成，也就是说在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间进行页面的渲染，及时地响应用户的交互。
## React18 有哪些新变化？
react18以于2022年3月29日发布正式版本。
* Concurrent Mode（以下简称 CM）翻译叫并发渲染机制：在以前，React 在状态变更后，会开始准备虚拟 DOM，然后渲染真实 DOM，整个流程是串行的。一旦开始触发更新，只能等流程完全结束，期间是无法中断的。
在 CM 模式下，React 在执行过程中，每执行一个 Fiber，都会看看有没有更高优先级的更新，如果有，则当前低优先级的的更新会被暂停，待高优先级任务执行完之后，再继续执行或重新执行。
* startTransition：主动降低优先级。本质上是用于一些不是很急迫的更新上，用来进行并发控制，在v18之前，所有的更新任务都被视为急迫的任务，而CM模式能将渲染中断，可以让高优先级的任务先更新渲染。
比如「搜索引擎的关键词联想」，用户在输入框中的输入希望是实时的，而联想词汇则不是很在意。我们可以用 startTransition 来降低联想词汇更新的优先级。
* 入口优化：现在是要先通过createRoot()创建一个 root 节点，然后该 root 节点来调用render()方法；后面再想重新渲染整个应用的时候，通过root节点进行render，就不用重新渲染这个根结点了。
* 全部自动批处理优化：批处理是 React 将多个状态更新分组到一个重新渲染中以获得更好的性能。（例如将多次 setstate 事件合并）；
在v17的批处理只会在事件处理函数中实现，在 v18 中所有更新都将自动批处理，包括 promise 链、setTimeout 等异步代码。
* useId：主要用于 SSR 服务端渲染的场景，方便在服务端渲染和客户端渲染时，产生唯一的 id；
## React的并发问题是如何处理的？
React 中的并发，是JS的逻辑代码会跟 UI 渲染竞争主线程。若一个很耗时的任务占据了线程，那么后续的执行内容都会被阻塞。
为了避免这种情况，React 就利用 fiber 结构和时间切片的机制，将一个大任务分解成多个小任务，然后按照任务的优先级和线程的占用情况，对任务进行调度。
* 对于每个更新，为其分配一个优先级 lane，用于区分其紧急程度。
* 通过 Fiber 结构将不紧急的更新拆分成多段更新，并通过宏任务的方式将其合理分配到浏览器的帧当中。这样就能使得紧急任务能够插入进来。
* 高优先级的更新会打断低优先级的更新，等高优先级更新完成后，再开始低优先级更新。
## React.Children.map 和 js 的 map 有什么区别？
JavaScript 中的 map 不会对为 null 或者 undefined 的数据进行处理，而 React.Children.map 中的 map 可以处理 React.Children 为 null 或者 undefined 的情况。
