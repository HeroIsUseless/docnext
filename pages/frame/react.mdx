# 初级
## React的运行原理是什么？
分为调和阶段和提交阶段
* 调和阶段是首先计算出状态变化后的虚拟DOM结构。然后计算出当前虚拟DOM结构修改为目标虚拟DOM结构的最优更新方案。
* 提交阶段是将调和阶段记录的更新方案应用到DOM中，然后调用暴露给开发者的钩子方法。
## React如何提高渲染性能？
* 避免不必要的渲染，使用PureComponent和React.memo，状态下放
* 列表性能优化
* 使用key属性
* 异步渲染
* 使用Memoization，使用useMemo和useCallback来避免不必要的函数重新计算，减少渲染开销。

## useCallback解决了什么问题？解决事件问题了吗？
即便不用useCallback，事件回调也不会有state过期啊，会有过期的，例如只在onMount阶段绑定，除非setTimeout会。
js创建一个函数的成本是非常小的，这点计算对于计算机来说是小case，useCallback的作用其实是用来避免子组件不必要的reRender。
防止React.memo破功。
## React的「更新」和「重新渲染」有什么区别？
React 的「更新」包含三个阶段：
* 渲染（Render），使用 createElement 或 jsx-runtime 产生全新的 React Element 对象、组装出一颗 React 树（也可能是一部分）；
* Reconcilation，React Reconciler 比较 新生成的 React 树 和 当前的 React 树，判断如何用最高效的方法实现「更新」；
* Commit，操作 Host（如 DOM、Native 等），使新的 UI 呈现在用户面前。

「重新渲染」一律指代 React 组件在「更新」时的「渲染」阶段。没有diff差距调和和提交不一定有事情干。
「更新」则指代（重新）渲染、Reconcilation 和 Commit 整个过程。

有的时候，你很难判断一个组件是否是纯组件。事实上，React 组件更新的开销没有想象中的那么大。但是比对的开销可能比想象的大。
如果一个组件接受很多复杂的 prop，有可能渲染这个组件并对比 Virtual DOM 的性能开销甚至小于等于浅比较所有 prop 的开销。
让 React 在 Runtime 中判断子组件的全部依赖、
以跳过子组件的不必要更新，是非常困难、非常不现实的。计算子组件依赖的最好时机是编译期间。
做缓存本身也是需要成本的，如果这个成本大于它所带来的收益，但就是负收益了，就变成无用了。

另外就是，对于减少重复渲染的优化策略来说，React.memo 实际上是一种“懒人”方法，相当于在错误的方向上越走越远，
因为有很多重复渲染问题是由于 state 的设计不合理导致的，比如本来是 local 的 state，
非要当做 global 来处理（滥用状态管理），又或者是编程习惯不好导致的（比如 render 中包含 inline object），所以也要具体情况具体分析。

React useMemo和memo会有性能问题，比如首次渲染、重新渲染、多次渲染场景下，memo有可能会有性能提升，也有可能会有性能损耗。

比如说5000次首次渲染和5000次重新渲染。

* 5000次重新渲染，不用memo比用memo慢10倍。
* 5000次首次渲染，不用memo比用memo快50倍。这该怎么取舍。

为什么“不要过早优化”？因为优化也有成本，可能带来新问题。甚至是性能问题。
## 为什么不能在if里使用hooks？
一旦在条件语句中声明 hooks,函数组件更新时,hooks 链表结构被破坏,currentFiber 树 的 memoizedState 
缓存 hooks 链表 的信息,和 workInProgress 不一致,如果涉及到读取 state 等操作，就会发生异常。因此不能在条件、循环语句中使用 hooks。
## 什么是受控组件和非受控组件？
* 受控组件：只能通过React修改数据或状态的组件，就是受控组件。
* 非受控组件：控件自己就能控制数据和状态的变更，而且React是不知道这些变更的，如 input, textarea, select, checkbox 等组件。
> 如何将非受控组件改为受控组件呢？那就是把组件数据或状态的变更，都交给React来操作。

## setState 的传参方式，有什么区别？
setState()的传参有两种方式：纯数据和回调函数。回调函数方式能在参数中获得最新state，多用于异步的情况。

## 了解React的虚拟dom吗？
虚拟DOM是以对象的方式来描述真实dom的。在做更新操作的时候，可以在内存中进行数据比对，
减少对真实dom的操作，从而减少浏览器重排重绘的次数，从而能提高程序的性能。

## 什么是PureComponent？
React.PureComponent 与 React.Component 几乎完全相同，但 React.PureComponent通过prop和state的浅对比来实现更新。
跳过类式组件不必要的重新渲染。类式组件 可以通过继承 PureComponent 来选择此行为。
在函数组件中，通过memo来实现相同的效果。

## react生命周期？
* componentWillMount() 组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。
* render() react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。
* componentDidMount() 组件渲染之后调用，只调用一次。
* componentWillReceiveProps(nextProps) 组件初始化时不调用，组件接受新的props时调用。
* shouldComponentUpdate(nextProps, nextState) 组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，
如果相同则返回false阻止更新，这样就不需要创造新的dom树和旧的dom树进行diff算法对比。
* componentWillUpdate(nextProps, nextState) 组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state。
* componentDidUpdate() 组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。
* componentWillUnmount() 组件将要卸载时调用，一些事件监听和定时器需要在此时清除。

## 什么是合成事件（事件代理），与原生事件有什么区别？
React中所有触发的事件，都在React实现的一个合成事件层。作用是
* 规范化了这些接口在不同浏览器中的行为，抹平了不同浏览器事件对象之间的差异，解决了浏览器兼容的问题，方便事件统一管理；
* 避免垃圾回收；react事件对象不会被释放掉，而是存放进一个数组中，避免频繁地去创建和销毁（垃圾回收）。

在 React 初始化渲染的时候，ReactDOM.render 会调用函数 listenToAllSupportedEvents 来绑定事件。
不支持冒泡事件的，React 会直接把事件绑定在具体的元素上。

对合成事件阻止不会影响原生事件的执行。

在React底层，主要对合成事件做了两件事：
* 事件委派： React会把所有的事件绑定到结构的最外层（Virtual DOM根节点），使用统一的事件监听器，
这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。
react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。
* 自动绑定： React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。

从v17.0.0开始, React 不会再将事件处理添加到 document 上, 而是将事件处理添加到渲染 React 树的根 DOM 容器中。

React 代码执行时，顶层会自动执行事件的注册，初始化事件插件。
React 首次渲染时，会在根节点上绑定所有原生事件。支持冒泡的事件，React 会同时绑定捕获阶段和冒泡阶段的事件；不支持冒泡的事件，会将事件绑定在具体 DOM 元素上。
事件触发前会从目标元素的 Fiber 节点向上收集同类型事件队列，构造合成对象，同类型的事件会复用同一个合成事件实例对象。
根据监听的事件阶段，决定顺序还是倒序遍历执行事件处理函数（模拟事件的冒泡捕获机制）。

事件注册：registerEvents；将80种事件类型添加到allNativeEvents的Set数据结构中。
事件监听：listenToAllSupportedEvents；遍历上面事件注册添加到allNativeEvents的事件。
监听的listener是一个事件派发器，并不是真实的浏览器事件或你写的事件回调函数。
事件派发：dispatchEvent；事件一旦在id = root的 DOM 元素中委托，其实是一直在触发的，
根据消息的数据找到真正触发事件的 DOM 元素，根据fiber节点的类型以及是否已渲染来决定是否要派发事件。
事件合成：SyntheticBaseEvent；当我们点击页面的某个元素时，React会根据原生事件nativeEvent找到触发事件的 DOM 元素
和对应的fiber节点。并以该节点为孩子节点往上查找，找到包括该节点及以上所有的click回调函数创建dispatchListener，
并添加到listeners数组中。同类型的事件会复用同一个合成事件实例对象。

react 默认事件代理的方式，实际上没有任何冒泡的过程，是程序自己模拟冒泡的操作。

当真实dom触发后冒泡到document后才会对react事件进行处理。

React合成事件是指将原生事件合成一个React事件。React有自己一套独立的事件系统,就是合成事件。
## key 的作用是什么？
当出现大量相同的标签时，使用key可以帮助diff算法提升判断的速度，从而使页面渲染更快消耗更少。

# 中级
## Redux 中异步的请求怎么处理
用中间件，但是只不过就是从请求回调里调用dispatch变成dispatch的参数设置成请求函数，换个写法可能更易读，但代码量一点也没少
## React.forwardRef是什么？它有什么作用？
React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。这种技术并不常见，但在以下两种场景中特别有用：
* 父组件调用子组件的方法
* 把子组件的refs转发上去
## 如何实现组件的懒加载？
从 16.6.0 开始，React 提供了 lazy 和 Suspense 来实现懒加载。
```js
import React, { lazy, Suspense } from 'react';
const OtherComponent = lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <OtherComponent />
    </Suspense>
  );
}
```
属性fallback表示在加载组件前，渲染的内容。
## 高阶组件（HOC）？
高阶组件通过包裹（wrapped）被传入的 React 组件，经过一系列处理，最终返回一个相对增强（enhanced）的 React 组件，供其他组件调用。

## React 的 diff 过程？
diff算法会高效地对比新旧虚拟DOM，找出真正的Dom变化之处，react中diff算法主要遵循三个层级的策略：
* tree层级，只会对相同层级的节点进行比较，而且只有创建、删除操作，没有移动操作
* conponent 层级，如果是同一类的组件，则会继续往下diff运算，如果不是同一类的组件，那么直接删除这个组件下的所有子节点，创建新的
* element 层级，每个节点在对应的层级用唯一的key作为标识，提供了插入，移动，删除操作
>  通过key可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置

## React和Vue的diff算法的异同？
共同点：
* vue和diff算法，都是只做同级比较，不进行跨层级比较
不同点：
* vue对比节点时，当节点元素类型相同，类名不同时，认为是不同的元素，删除重新创建，而react认为是同类型的节点，进行修改操作。
* vue的列表比对，采用从两端到中间的比对方式，而react则采用从左到右依次比对的方式。
例如当一个集合，只是把最后一个节点移动到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移动到第一个。

## redux原理？
将所有状态进行集中管理

# 高级
## 什么是React Portal？有哪些使用场景？
```js
ReactDOM.createPortal(child, container)
```
Portals 提供了一种脱离 #app 的组件。特别是 position: absolute 与 position: fixed 的组件。比如模态框，通知，警告，goTop 等。
## cloneElement 与 createElement 各是什么，有什么区别？
* cloneElement，根据 Element 生成新的 Element，新添加的属性会并入原有的属性 一般配合 React.children.map使用，如用于动态地给子组件添加更多 props 信息、样式
* createElement，根据 Type 生成新的 Element，
第一个参数是 type 简单来说就是各种标签名字，第二个参数是传入的属性，第三个参数以及之后的参数就是作为组件的子组件。

## React18 有哪些新变化？
react18以于2022年3月29日发布正式版本。
* Concurrent Mode（以下简称 CM）翻译叫并发渲染机制：在以前，React 在状态变更后，会开始准备虚拟 DOM，然后渲染真实 DOM，整个流程是串行的。一旦开始触发更新，只能等流程完全结束，期间是无法中断的。
在 CM 模式下，React 在执行过程中，每执行一个 Fiber，都会看看有没有更高优先级的更新，如果有，则当前低优先级的的更新会被暂停，待高优先级任务执行完之后，再继续执行或重新执行。
* startTransition：主动降低优先级。本质上是用于一些不是很急迫的更新上，用来进行并发控制，在v18之前，所有的更新任务都被视为急迫的任务，而CM模式能将渲染中断，可以让高优先级的任务先更新渲染。
比如「搜索引擎的关键词联想」，用户在输入框中的输入希望是实时的，而联想词汇则不是很在意。我们可以用 startTransition 来降低联想词汇更新的优先级。
* 入口优化：现在是要先通过createRoot()创建一个 root 节点，然后该 root 节点来调用render()方法；后面再想重新渲染整个应用的时候，通过root节点进行render，就不用重新渲染这个根结点了。
* 全部自动批处理优化：批处理是 React 将多个状态更新分组到一个重新渲染中以获得更好的性能。（例如将多次 setstate 事件合并）；
在v17的批处理只会在事件处理函数中实现，在 v18 中所有更新都将自动批处理，包括 promise 链、setTimeout 等异步代码。
* useId：主要用于 SSR 服务端渲染的场景，方便在服务端渲染和客户端渲染时，产生唯一的 id；

## redux与vuex的区别？

* redux使用的是不可变数据，每次都是用新的state替换旧的state，通过diff算法比较差异的；而Vuex是可变的，通过getter/setter直接修改。
* 另外就是在api上有不同，vuex定义了state，getter，mutation，action；redux定义了state，reducer，action。

## React18的useEffect会执行两次？
这是 React18 才新增的特性。仅在开发模式("development")下，且使用了严格模式("Strict Mode")下会触发。
React18 在开发环境中除了必要的挂载之外，还 "额外"模拟执行了一次组件的卸载和挂载。
生产环境("production")模式下和原来一样，仅执行一次。
当然，人家就是这么干了，作为 React 的普通使用者，能做的就是 适应它 ，并按照它的规范来做。
正确的问题不是“怎么样让 Effect 执行一次”，而是“怎样修复我的 Effect，让它在(重复)挂载之后正常工作”

React.StrictMode 是帮助应用适应异步渲染的组件。
React.StrictMode 是在 2018 年的 16.3.0 版本中引入的组件。
一开始，它只用在类组件中，而在 16.8.0 中，它对 hook 同样适用。
React.StrictMode 不能马上检测到副作用，但是它可以通过故意调用一些关键函数两次，来帮助我们发现副作用。
类组件 constructor、render 以及 shouldComponentUpdate 方法
类组件静态 getDerivedStateFromProps 方法。
渲染两次指的是函数组件被调用两次。

你可以通过将组件按纯函数严格编写，以避免一些随着代码库的增长而出现的、令人困扰的 bug 以及不可预测的行为。
更新屏幕、启动动画、更改数据等，它们被称为 副作用。它们是 “额外” 发生的事情，与渲染过程无关。
在 React 中，副作用通常属于 事件处理程序。事件处理程序是 React 在你执行某些操作（如单击按钮）时运行的函数。
即使事件处理程序是在你的组件 内部 定义的，它们也不会在渲染期间运行！ 因此事件处理程序无需是纯函数。

纯函数 通常具有如下特征：
* 只负责自己的任务。它不会更改在该函数调用前就已存在的对象或变量。
* 输入相同，则输出相同。给定相同的输入，纯函数应总是返回相同的结果。

React 假设你编写的所有组件都是纯函数。也就是说，对于相同的输入，你所编写的 React 组件必须总是返回相同的 JSX。
* 不能读取和修改全局变量，可以传到props里
* 输入可以理解为props，state，context，输出可以理解为render的返回jsx
