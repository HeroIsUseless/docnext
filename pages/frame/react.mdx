# 初级
## useState塞入默认值是从props内拿到的时候，会发生什么？
state不会随着props变化，useState只执行一次，因此用useMemo比较好
为什么虚拟 dom 会提高性能
虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要 的 dom 操作，从而提高性能，
具体实现步骤如下:
* 用 JavaScript 对象结构表示 DOM 树的结构;然后用这个树构建一个真正的 DOM 树， 插到文档当中;
* 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记 录两棵树差异;
* 把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。
## 什么是受控组件和非受控组件？
* 受控组件：只能通过 React 修改数据或状态的组件，就是受控组件；
* 非受控组件：与受控组件相反，如 input, textarea, select, checkbox 等组件，本身控件自己就能控制数据和状态的变更，而且 React 是不知道这些变更的；
* 那么如何将非受控组件改为受控组件呢？那就是把上面的这些纯 html 组件数据或状态的变更，交给 React 来操作
## useState 的传参方式，有什么区别？
useState()的传参有两种方式：纯数据和回调函数。回调函数方式能在参数中获得最新state，多用于异步的情况。
## 为什么在本地开发时，组件会渲染两次？
在 React.StrictMode 模式下，如果用了 useState,usesMemo,useReducer 之类的 Hook，React 会故意渲染两次，为的就是将一些不容易发现的错误容易暴露出来，同时 React.StrictMode 在正式环境中不会重复渲染。
也就是在测试环境的严格模式下，才会渲染两次。
## useEffect()的清除机制是什么？在什么时候执行？
useEffect(callback)的回调函数里，若有返回的函数，这是 effect 可选的清除机制。每个 effect 都可以返回一个清除函数。

React 会在组件卸载的时候执行清除操作。若组件产生了更新，会先执行上一个的清除函数，然后再运行下一个 effect。
## 了解React的虚拟dom吗？
Virtual DOM 是以对象的方式来描述真实 dom 对象的，在做一些 update 的时候，可以在内存中进行数据比对，
减少对真实 dom 的操作减少浏览器重排重绘的次数，提高程序的性能，虚拟 dom 增加了一层内存运算，然后才操作真实 dom，将数据渲染到页面上。渲染上肯定会慢上一些。

## 什么是PureComponent？
React.PureComponent 与 React.Component 几乎完全相同，但 React.PureComponent通过prop和state的浅对比来实现更新

Javascript 的 Pure Functions 是什么？不依赖函数范围以外的变量而独自内部生存的函数。
可以自己决定自己的结果，自力更生，如果输入值不变则一定会一直得出相同的结果。且它的输出结果一定要基于自己的输入参数。
由于每次如果输入值不变一定会结果相同，重复运行函数时，Chrome V8 Engine会返回cached的结果，而不是重新运行一遍函数，大大提高了整个项目的运行速度。
一个不返回任何结果的函数也不是一个pure function。

跳过类式组件不必要的重新渲染，当父组件重新渲染时，React 通常会重新渲染子组件。为了优化性能，你可以创建一个组件，在父组件重新渲染时不会重新渲染，
前提是新的 props 和 state 与旧的 props 和 state 相同。类式组件 可以通过继承 PureComponent 来选择此行为。

在函数组件中，通过memo来实现相同的效果。

## react生命周期？


## 什么是合成事件（事件代理），与原生事件有什么区别？
React 中所有触发的事件，都是自己在其内部封装了一套事件机制（基于Virtual DOM实现了一个SyntheticEvent层（合成事件层））。目的是为了实现全浏览器的一致性，抹平不同浏览器之间的差异性。
React 合成事件采用的是事件冒泡机制，当在某具体元素上触发事件时，等冒泡到顶部被挂载事件的那个元素时，才会真正地执行事件。

在React底层，主要对合成事件做了两件事：
* 事件委派： React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了
一个映射来保存所有组件内部事件监听和处理函数。
* 自动绑定： React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。
* react 事件不能采用 return false 的方式来阻止浏览器的默认行为，而必须要地明确地调用preventDefault()来阻止默认行为。

## key 的作用是什么？
当出现大量相同的标签时，使用key可以帮助diff算法提升判断的速度，在页面重新渲染时更快消耗更少，因此你应当给数组中的每一个元素赋予一个确定的标识。
## 多次执行 setState()，会触发多次更新吗？
在 React18 中，无论是多个 useState()的 hook，还是操作（dispatch）多次的数据。只要他们在同一优先级，React 就会将他们合并到一起操作，最后再更新数据。
这是基于 React18 的批处理机制。React 将多个状态更新分组到一个重新渲染中以获得更好的性能。（将多次 setstate 事件合并）；在 v18 之前只在事件处理函数中实现了批处理，在 v18 中所有更新都将自动批处理，包括 promise 链、setTimeout 等异步代码以及原生事件处理函数；

# 中级
## Redux 中异步的请求怎么处理
用中间件，但是只不过就是从请求回调里调用dispatch变成dispatch的参数设置成请求函数，换个写法可能更易读，但代码量一点也没少
## React.forwardRef是什么？它有什么作用？
React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。这种技术并不常见，但在以下两种场景中特别有用：
* 父组件调用子组件的方法
* 把子组件的refs转发上去
## 如何实现组件的懒加载？
从 16.6.0 开始，React 提供了 lazy 和 Suspense 来实现懒加载。
```js
import React, { lazy, Suspense } from 'react';
const OtherComponent = lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <OtherComponent />
    </Suspense>
  );
}
```
属性fallback表示在加载组件前，渲染的内容。
## 高阶组件（HOC）？
高阶组件通过包裹（wrapped）被传入的 React 组件，经过一系列处理，最终返回一个相对增强（enhanced）的 React 组件，供其他组件调用。
## React 的 diff 过程
React 只对比当前层级的节点，不跨层级进行比较；
根据不同的节点类型，如函数组件节点、类组件节点、普通 fiber 节点、数组节点等，进入不同的处理函数；
前后两个 fiber 节点进行对比，若 type 不一样，直接舍弃掉旧的 fiber 节点，创建新的 fiber 节点；若 key 不一样，则需要根据情况判断，若是单个元素，则直接舍弃掉，创建新的 fiber 节点；若是数字型的元素，则查找是否移动了位置，若没找到，则创建新的节点；若 key 和 type 都一样，则接着往下递归；
若是单个 fiber 节点，则直接返回；若是并列多个元素的 fiber 节点，这里会形成单向链表，然后返回头指针（该链表最前面的那个 fiber 节点）；
通过上面的 diff 对比过程，我们也可以看到，当组件产生比较大的变更时，React 需要做更多的动作，来构建出新的 fiber 树，因此我们在开发过程中，若从性能优化的角度考虑，尤其要注意的是：
节点不要产生大量的越级操作：因为 React 是只进行同层节点的对比，若同一个位置的子节点产生了比较大的变动，则只会舍弃掉之前的 fiber 节点，从而执行创建新 fiber 节点的操作；React 并不会把之前的 fiber 节点移动到另一个位置；相应的，之前的 jsx 节点移动到另一个位置后，在进行前后对比后，同样会执行更多的创建操作；
不修改节点的 key 和 type 类型，如使用随机数做为列表的 key，或从 div 标签改成 p 标签等操作，在 diff 对比过程中，都会直接舍弃掉之前的 fiber 节点及所有的子节点（即使子节点没有变动），然后重新创建出新的 fiber 节点；
## redux原理？
## diff算法如何比较?
diff算法就是更高效地通过对比新旧Virtual DOM来找出真正的Dom变化之处，从而最高效地更新dom
* DOM节点跨层级的操作不做优化，只会对相同层级的节点进行比较，只有删除、创建操作，没有移动操作

* 如果是同一个类的组件，则会继续往下diff运算，如果不是一个类的组件，那么直接删除这个组件下的所有子节点，创建新的

* 对于比较同一层级的节点们，每个节点在对应的层级用唯一的key作为标识，通过key可以准确地发现新旧集合中的节点都是相同的节点，因此无需进行节点删除和创建，只需要将旧集合中节点的位置进行移动，更新为新集合中节点的位置

能移动则移动，不能移动的再新增删除
## React和Vue的diff算法的异同？
共同点：
* vue和diff算法，都是不进行跨层级比较，只做同级比较
不同点：
* vue对比节点时，当节点元素类型相同，类名不同时，认为是不同的元素，删除重新创建，而react认为是同类型的节点，进行修改操作。
* vue的列表比对，采用从两端到中间的比对方式，而react则采用从左到右依次比对的方式。
例如当一个集合，只是把最后一个节点移动到了第一个，react会把前面的节点依次移动，而vue只会把最后一个节点移动到第一个。
总体上，vue的对比方式更高效。
这样的操作来看，Vue的diff性能是高于react的
# 高级
## 什么是React Portal？有哪些使用场景？
```js
ReactDOM.createPortal(child, container)
```
Portals 提供了一种脱离 #app 的组件。特别是 position: absolute 与 position: fixed 的组件。比如模态框，通知，警告，goTop 等。
## cloneElement 与 createElement 各是什么，有什么区别？
* cloneElement，根据 Element 生成新的 Element，新添加的属性会并入原有的属性 一般配合 React.children.map使用，如用于动态地给子组件添加更多 props 信息、样式
* createElement，根据 Type 生成新的 Element，
第一个参数是 type 简单来说就是各种标签名字，第二个参数是传入的属性，第三个参数以及之后的参数就是作为组件的子组件。
## React16的fiber架构？
默认情况下，JavaScript 运算、页面布局和页面绘制都是运行在浏览器的主线程当中，他们之间是互斥的关系，如果 JavaScript 运算持续占用主线程，页面就没法得到及时的更新，
阻塞了浏览器的 UI 渲染，Fiber 架构将更新任务分解成小的、可中断的单元，分批完成，也就是说在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间进行页面的渲染，及时地响应用户的交互。
## React18 有哪些新变化？
react18以于2022年3月29日发布正式版本。
* Concurrent Mode（以下简称 CM）翻译叫并发渲染机制：在以前，React 在状态变更后，会开始准备虚拟 DOM，然后渲染真实 DOM，整个流程是串行的。一旦开始触发更新，只能等流程完全结束，期间是无法中断的。
在 CM 模式下，React 在执行过程中，每执行一个 Fiber，都会看看有没有更高优先级的更新，如果有，则当前低优先级的的更新会被暂停，待高优先级任务执行完之后，再继续执行或重新执行。
* startTransition：主动降低优先级。本质上是用于一些不是很急迫的更新上，用来进行并发控制，在v18之前，所有的更新任务都被视为急迫的任务，而CM模式能将渲染中断，可以让高优先级的任务先更新渲染。
比如「搜索引擎的关键词联想」，用户在输入框中的输入希望是实时的，而联想词汇则不是很在意。我们可以用 startTransition 来降低联想词汇更新的优先级。
* 入口优化：现在是要先通过createRoot()创建一个 root 节点，然后该 root 节点来调用render()方法；后面再想重新渲染整个应用的时候，通过root节点进行render，就不用重新渲染这个根结点了。
* 全部自动批处理优化：批处理是 React 将多个状态更新分组到一个重新渲染中以获得更好的性能。（例如将多次 setstate 事件合并）；
在v17的批处理只会在事件处理函数中实现，在 v18 中所有更新都将自动批处理，包括 promise 链、setTimeout 等异步代码。
* useId：主要用于 SSR 服务端渲染的场景，方便在服务端渲染和客户端渲染时，产生唯一的 id；
## React的并发问题是如何处理的？
React 中的并发，是JS的逻辑代码会跟 UI 渲染竞争主线程。若一个很耗时的任务占据了线程，那么后续的执行内容都会被阻塞。
为了避免这种情况，React 就利用 fiber 结构和时间切片的机制，将一个大任务分解成多个小任务，然后按照任务的优先级和线程的占用情况，对任务进行调度。
* 对于每个更新，为其分配一个优先级 lane，用于区分其紧急程度。
* 通过 Fiber 结构将不紧急的更新拆分成多段更新，并通过宏任务的方式将其合理分配到浏览器的帧当中。这样就能使得紧急任务能够插入进来。
* 高优先级的更新会打断低优先级的更新，等高优先级更新完成后，再开始低优先级更新。
## React.Children.map 和 js 的 map 有什么区别？
JavaScript 中的 map 不会对为 null 或者 undefined 的数据进行处理，而 React.Children.map 中的 map 可以处理 React.Children 为 null 或者 undefined 的情况。
## redux与vuex的区别？

* redux使用的是不可变数据，每次都是用新的state替换旧的state，通过diff算法比较差异的；而Vuex是可变的，通过getter/setter直接修改。
* 另外就是在api上有不同，vuex定义了state，getter，mutation，action；redux定义了state，reducer，action。

## 说一下Redux功能化编程的概念？
在redux中使用了功能化编程的概念。在参数中可以传递函数。使用了数据流控制, 递归调用, 函数和数组等等。帮助函数, 如reduce和map filter被大量使用。
允许函数的串联。状态只读。代码执行顺序的优先级没有必要考虑。
