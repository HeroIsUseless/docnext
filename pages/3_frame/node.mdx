## V8是什么？Node是什么？Node JS与V8是什么关系？
V8 是一个JavaScript引擎，能将JavaScript代码直接编译成本地平台的机器码并执行。

Node是一个基于V8引擎的JavaScript运行环境，能让JavaScript 运行在服务端。
* 一方面，它提供了多种API，例如读写文件、网络请求、系统信息等。
* 另一方面，它还负责将JavaScript代码直接编译成本地平台的机器码并执行，这部分工作是由V8引擎完成。

V8 引擎是 Node.js 的核心组成部分，负责执行 JavaScript 代码，
而 Node.js 为 V8 提供了运行环境和API，使其能够在服务器端运行。

## Node与浏览器的事件循环的差异？
浏览器环境下，每执行完一个宏任务就执行所有微任务队列。

在Node 10之前，微任务会在事件循环的各个阶段之间执行，
Node 11以后和浏览器的行为统一了，都是每执行完一个宏任务就执行所有微任务队列。

> Node的事件循环分为6个阶段，它们会按照顺序反复运行。
每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。
当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。

## node的stream是什么？
Node.js 中的流（Stream）是一种处理数据的方式，它允许你以流的方式处理数据，而不是一次性加载整个数据集。这种方式对于处理大量数据非常有用，因为它可以减少内存的使用并提高性能。
使用 Node.js 流的一个例子：
* 创建一个流对象（例如，使用 fs.createReadStream() 或 fs.createWriteStream()）。
* 监听 ‘data’ 事件来接收从流中读取的数据。
* 监听 ‘end’ 事件来知道何时数据已经读取完毕。
* 监听 ‘error’ 事件来处理可能发生的错误。

管道流（Pipeline Stream）是一种特殊的流操作，它通过将多个流连接在一起，实现数据的连续处理和传输。在 Node.js 中，可以通过将多个流连接在一起，形成一个管道流，以便将数据从一个流中传递到另一个流中。
例如将可读流、转换流和可写流连接起来，形成一个管道流：
readableStream.pipe(transformStream).pipe(writableStream);

## 为什么有node buffer？
在过去的js中，js是为浏览器而生的，在浏览器中，js本身是没有IO操作的，js发什么ajax请求、选择文件上传，看起来js有IO操作，实际上这都是由浏览器自身底层代码在操作系统上实现，js本身是没有IO的，因为没有IO所以过去的js也没有二进制数据的表示和处理方案。而到了node这里，node就相当于是浏览器底层了，直接和操作系统打交道，而浏览器的js，只是在和浏览器打交道，浏览器再和操作系统打交道。
node中不管是读数据还是写数据，不管这个数据是来自还是去向网络还是磁盘，这些IO操作的数据都在内存缓冲区中中转。node因为要处理这些网络、磁盘等IO操作，这些IO操作都是二进制数据，因此node增加了Buffer类型。
node读取出来的文件默认就是buffer数据，也就是读取出来的就是放在内存缓冲区的二进制数据。

## 简单聊聊 Node 的异步 I/O？
当进行非阻塞 I/O 调用时，要读到完整的数据，应用程序需要进行多次轮询，才能确保读取数据完成，以进行下一步的操作。
read 是性能最低的一种，它通过重复调用来检查 I/O 的状态来完成完整数据读取。select 是一种改进方案，通过对文件描述符上的事件状态来进行判断。轮询技术满足了异步 I/O 确保获取完整数据的保证。但是对于应用程序而言，它仍然只能算时一种同步，因为应用程序仍然需要主动去判断 I/O 的状态，依旧花费了很多 CPU 时间来等待。
在 Linux 下存在一种这种方式，它原生提供了一种异步非阻塞 I/O 方式（AIO）即是通过信号或回调来传递数据的。
不幸的是，只有 Linux 下有这么一种支持，而且还有缺陷（AIO 仅支持内核 I/O 中的 O_DIRECT 方式读取，导致无法利用系统缓存。

另一种理想的异步 I/O 是采用阻塞 I/O，但加入多线程，将 I/O 操作分到多个线程上，利用线程之间的通信来模拟异步。
然而遗憾在于，它存在一些难以忍受的缺陷和 bug 。可以简单的概述为：Linux 平台下没有完美的异步 I/O 支持。
那么在 Windows 平台下的状况如何呢？而实际上，Windows 有一种独有的内核异步 IO 方案：IOCP。IOCP 的思路是真正的异步 I/O 方案，调用异步方法，然后等待 I/O 完成通知。IOCP 内部依旧是通过线程实现，不同在于这些线程由系统内核接手管理。IOCP 的异步模型与 Node.js 的异步调用模型已经十分近似。

以上两种方案则正是 Node.js 选择的异步 I/O 方案。由于 Windows 平台和 *nix 平台的差异，Node.js 提供了 libuv 来作为抽象封装层，使得所有平台兼容性的判断都由这一层次来完成，保证上层的 Node.js 与下层的 libeio/libev 及 IOCP 之间各自独立。Node.js 在编译期间会判断平台条件，选择性编译 unix 目录或是 win 目录下的源文件到目标程序中。

## Node 更适合处理 I/O 密集型任务还是 CPU 密集型任务？为什么？
当然是io密集型，当然也有多线程机制workThread
