# 初级
## var，let，const，死区？
var，let，const声明用法是一样，都是定义变量，var的声明会被提升到全局作用域或函数作用域，但仍然在原地方赋值。let，const并不会声明提升，因此在声明之前的代码区域就是暂时性死区。
## call，apply，bind的区别？
三者的功能都是用来改变函数中的 this 指向。
* call() 方法是预定义的 JavaScript 方法。它可以用来调用所有者对象作为参数的方法。通过 call()，您能够使用属于另一个对象的方法。call传入的参数数量不固定，第一个参数代表函数内的this指向，从第二个参数开始往后，每个参数被依次传入函数。 
```js
  const person = {
    fullName: function (country, city) {
      return this.firstName + this.lastName + " " + country + " " + city
    }
  }
  const newPerson = {
    firstName: "fu",
    lastName: "chaoyang",
  }
  person.fullName.call(newPerson, 'china', 'xian') // fuchaoyang china xian 
```
* apply() 对比 call() 仅参数上的不同：接受两个参数，第一个参数指定了函数体内的this指向。第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数。
```js
  const person = {
    fullName: function (country, city) {
      return this.firstName + this.lastName + " " + country + " " + city
    }
  }
  const newPerson = {
    firstName: "fu",
    lastName: "chaoyang",
  }
  person.fullName.apply(newPerson, ['china', 'xian']) // fuchaoyang china xian
```
* bind() 相对 call() 而言，仅绑定新对象，不立即执行。
```js
  const person = {
    fullName: function (country, city) {
      return this.firstName + this.lastName + " " + country + " " + city
    }
  }
  const newPerson = {
    firstName: "fu",
    lastName: "chaoyang",
  }
  person.fullName.bind(newPerson, 'china', 'xian') // 打印出fullName函数
  person.fullName.bind(newPerson, 'china', 'xian')() // fuchaoyang china xian
```
> 手写call函数
>```js
>  // call实现
>  Function.prototype.myCall = function (context) {
>    const arg = [...arguments].slice(1)
>    const fn = Symbol()
>    context[fn] = this
>    const result = context[fn](...arg)
>    delete context[fn]
>    return result
>  }
>```
## 说一下原型和原型链？
JavaScript 中，万物皆对象，对象分为普通对象和函数对象，所有的函数都是函数对象（`typeof f === 'function'`），其他都是普通对象（`typeof o === 'object'`）。

JS在没有类`class`前，创建一个对象都是通过 `new 函数()` 来实现的，例如：
```js
var a = new Object() // 此时a是{}
var a = {} // 等价于 var a = new Object()
function b() {}
var a = new b() // 此时a是{}
```
在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象。

原型对象是函数内维护的一个对象模版，当 `new 函数()` ，就会把这个对象拷贝一份返回，例如：
```js
function b() {
    b.prototype.c = 1
    b.prototype.d = '2'
}
var a = new b() // 此时a为{c: 1, d: '2'}
```
另外，JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做__proto__的内置属性，用于指向创建它的构造函数的原型对象，例如在上面👆的例子中，`a.__proto__ === b.prototype`。

每个对象都有__proto__属性，但只有函数对象才有 prototype 属性。
在默认情况下，所有的对象（包括函数对象和原型对象）都会自动获得一个 constructor（构造函数）属性，这个属性（是一个指针）指向 prototype 属性所在的函数，例如在上面👆的例子中，`a.constructor === b.prototype.constructor === b.constructor === b`。

> 注意`Function.prototype`是函数对象，但没有prototype属性，即`Function.prototype.prototype === undefined`

原型链：在多重继承中，一个对象可以是原型的拷贝，同时也是另一个对象的原型。因此，当你尝试访问对象上的属性时，JavaScript引擎开始从对象自身中查找该属性，如果没有，它会继续检查__proto__，一直到没有__proto__或者找到该属性。如果找到最后，此属性不存在时，返回undefined。
> 原型链的最上层是`Object.prototype`

## 讲一讲js的this指针？
* 全局的this指针指向windows（在严格模式下，全局作用域中的 this 的值是 undefined）。
* 当一个函数被调用时，this被绑定为全局对象，在浏览器环境下是window对象，非严格模式下，函数中的this指向window。
* 当一个方法（当函数被保存为一个对象的属性时）被调用时，this被绑定到这个对象上。
* 如果在一个函数前面加上new关键字来调用（当构造函数用），函数中的this会被绑定到这个新对象上。
* 对象里的this指向window。例如：`a = {b: this.k}`，此时this指向windows。
* call/apply/bind，this指针会绑定指定的对象。
* 事件的this指针指向元素本身。
* 箭头函数中的this是指向箭头函数定义时的离箭头函数最近的一个函数的this。
## 手写new？
```js
//Fun为构造函数, args表示传参
function myNew(Fun, ...args) {
    // 1.在内存中创建一个新对象
    let obj = {};
    
    // 2.把新对象的原型指针指向构造函数的原型属性
    obj.__proto__ = Fun.prototype;
    
    // 3.改变this指向，并且执行构造函数内部的代码（传参）
    let res = Fun.apply(obj, args);
    
    // 4.判断函数执行结果的类型
    if (res instanceof Object) {
        return res;
    } else {
        return obj;
    }
}

let obj = myNew(One, "XiaoMing", "18");
console.log("newObj:", obj);
```
## 闭包是什么？
闭包是指一个函数可以访问和使用其定义外部的变量，让这些变量的值始终保持在内存中，同时提供很好的封装和抽象。
## 手写防抖节流？
* 防抖（debounce）：每次触发定时器后，取消上一个定时器，然后重新触发定时器。防抖一般用于用户未知行为的优化，比如搜索框输入实时提示。
  ```js
  let timer;
  function debounce(cb, time) {
    clearTimeout(timer);
    timer = setTimeout(() => {
        cb();
    }, time)
  }
  
  onInputChange(text) {
    debounce(() => {
      // 获取实时提示
    }, 100)
  }
  ```
  ```js
  // 复杂一点的
  function debounce(func, time) {
    let timer;
    return function() {
      const [that, args] = [this, arguments];
      clearTimeout(timer)
      timer = setTimeout(() => {
        func.apply(that, args);
      }, time);
    }
  }

  onInputChange = debounce((text) => {
    // 获取实时提示
  }, 1000)
  ```
* 节流（throttle）：每次触发定时器后，直到这个定时器结束之前无法再次触发该函数。一般用于可预知的用户行为的优化，比如限制按钮点击的触发频率，防止重复的提交。
```js
let previous = 0;
function throttle(cb, time) {
  const now = Date.now();
  if (now - previous > time) {
    cb();
    previous = now;
  }
}

onButtonClick() {
  throttle(() => {
    // 提交表单
  }, 1000)
}
```
```js
// 复杂一点的
function throttle(func, time) {
  let previous = 0;
  return function() {
    const [that, args] = [this, arguments];
    const now = Date.now();
    if (now - previous > time) {
      previous = now;
      func.apply(that, args);
    }
  }
}
```
## 事件循环机制？
JS是一门单线程的语言，通过事件循环机制实现单线程异步的。JS所有同步任务都在主线程上执行，即执行栈。主线程之外还存在一个任务队列(也有人称之为消息队列)，用于执行异步任务。事件循环的工作流程如下：
* 首先，检查执行栈，看看是否有同步任务需要运行。
* 如果执行栈为空，那么就查看任务队列。
* 如果任务队列中有待处理的任务，那么就将它移出队列并放入调用堆栈，以便执行它的回调函数。

在JavaScript中，任务队列可以分为宏任务队列和微任务队列。在一个事件循环迭代中，首先会执行一个宏任务，然后执行所有的微任务。当所有的微任务完成后，再执行下一个宏任务。
宏任务包括如setTimeout，setInterval，setImmediate，I/O，UI rendering等，而微任务包括如Promise,MutationObserver等。

## 捕获与冒泡？
在 HTML 中，当事件被触发时，事件会经过三个阶段：捕获阶段、目标阶段和冒泡阶段。
* 捕获阶段（Capture Phase）：从 document 对象开始，逐级向下传递，直到事件源元素。在捕获阶段，事件处理函数会按照由外向内（由父元素到子元素）的顺序被依次执行。
* 目标阶段（Target Phase）：当事件传递到事件源元素时，就进入了目标阶段。在目标阶段，事件处理函数会被执行，此时可以通过 event.target 属性获取到具体触发事件的元素。
* 冒泡阶段（Bubble Phase）：从事件源元素开始，逐级向上传递，直到 document 对象。在冒泡阶段，事件处理函数会按照由内向外（由子元素到父元素）的顺序被依次执行。

在捕获阶段中，可以通过 addEventListener() 函数的第三个参数（选项）设置 capture 选项来监听事件的捕获阶段，否则监听将在冒泡阶段触发。

事件传递过程中，如果事件处理函数调用了 event.stopPropagation() 方法，当侦听的事件是捕获时,阻断的就是捕获过程,当侦听的事件是冒泡时,阻断的就是冒泡过程。
## typeof，instantof是什么？
* typeof是一个运算符，返回值是一个字符串，用来说明变量的数据类型，可以用此来判断number, string, object, boolean, function, undefined, symbol 这七种类型。对于对象、数组、null 返回的值是 object。
* instanceof运算符用于指示一个变量是否属于某个对象的实例。返回值为布尔值。instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。
## 讲一讲es5/6/7/8/9新特点？
* **ECMAScript 5 也称为 ES5 和 ECMAScript 2009。**
    + `"use strict"` 指令。例如，使用严格模式，不能使用未声明的变量
    + `String.trim()/charAt()` 删除字符串两端的空白字符
    + `Array.isArray()/forEach()/map()/fliter()/indexOf()/reduce()`
    + `JSON.parse()/stringify()`
    + `Date.now()`
    + `Object.key()/defineProperty()/getPrototypeOf()`等
    + 属性 Getter 和 Setter
* **ECMAScript 6，也被称为ES6和ES2015，是JavaScript的第六个版本**
    + let 和 const 以及块级作用域，在ES6之前，JavaScript只有全局作用域和函数作用域，没有块级作用域。
    + 模板字符串
    + `String.startWith()/endWith()`
    + 箭头函数
    + 函数参数的默认值，剩余参数
    + 解构赋值，展开运算符
    + 对象字面量的增强：属性和方法的简洁表示法，方括号表示法
    + `Object.keys()/values()/entries()/assign()`
    + 全局作用域中的 this 指向，在严格模式下，全局作用域中的 this 的值是 undefined。在非严格模式下，它会指向全局对象（浏览器中是 window 对象，Node.js 中是 global 对象）。
    + `Array.includes()/find()/from()/fill()`
    + set和map数据结构
    + 遍历器与for…of循环
* **ES2016（ES7）**
    + 幂运算符** 但一般也没有什么需求会用到幂乘
    + `Array.prototype.includes()`，第二个参数是从第几个下标开始搜，默认0
* **ES2017 ES8**
    + `Object.values`, `Object.entries`
    + 结尾允许逗号
    + async异步函数
* **ES2018 ES9**
    + 异步循环，同步循环中调用能引起等待的异步函数，是不会达到预期目的，循环本身依旧保持同步，并在内部异步函数之前完成。因此新增异步循环`for await(let i of array)`
    + 异步的finally
    + 对象的展开运算符，这项特性在ES6中已经引入，但是仅限于数组。
* **ES2019 ES10**
    + catch的参数e可以省略掉
    + `Object.fromEntries()`方便地将键值对列表（例如 Map、数组(符合键值对的)等）转换为一个对象。
    + `Array.flat()`能将高维数组降一维。
* **ES 2020 (ES11)**
    + 可选链操作符
    + BigInt 它是JavaScript的第7个原始类型，可安全地进行大数整型计算。 只需要在数字后面加上 n 即可。但不能将 BigInt与Number算术计算。
## `for in`, `for of`区别？
* `for in`循环返回的值都是对象的键值名(数组即下标)，遍历顺序有可能不是按照实际数组的内部顺序，使用for… in会遍历数组/对象所有的可枚举属性，包括继承属性，原型。所以不适合遍历数组，更适合遍历对象。
* for… of 循环用来获取一对键值对中的值，相对于forEach而言可以与 break、continue和return 配合使用，可以随时退出循环。但for…of循环内部调用的是数据结构的Symbol.iterator方法。
因此不能遍历对象，因为没有迭代器对象，可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator 对象，以及字符串。
> 在ECMAScript规范中定义了 「数字属性应该按照索引值⼤⼩升序排列，字符串属性根据创建时的顺序升序排列。」在这⾥我们把对象中的数字属性称为 「排序属性」，在V8中被称为 elements，字符串属性就被称为 「常规属性」， 在V8中被称为 properties。
## 遍历对象的几种方法？
* `for...in`
* `Object.keys()`，参数是一个对象，返回是该对象的key数组
* `Object.values()`，参数是一个对象，返回是该对象的value数组
* `Object.entries()`，返回值为Object.values()与Object.keys()的结合，返回一个二维数组，每个小数组都是[ [属性名，属性值],[属性名，属性值] ]
* `Object.getOwnPropertyNames()`，其返回结果与Object.keys()相似，但会返回对象得所有属性，包括了不可枚举属性
## JS 的array的函数中，有哪些是直接修改数组本体？
* 改变原数组的方法：
`pop()`,`push()`, `shift()`,`unshift()`,`splice()`,`sort()`,`reverse()`
* 不改变原数组的方法：
`slice()`,`concat()`
## 深拷贝浅拷贝的区别？如何实现一个深拷贝？
* 浅拷贝是拷贝一层，属性为对象时，浅拷贝是复制，两个对象指向同一个地址，`Object.assign()`，拓展运算符都是浅拷贝
* 深拷贝是递归拷贝深层次，属性为对象时，深拷贝是新开栈，两个对象指向不同的地址，`JSON.stringify()`是深拷贝，但是会忽略undefined、symbol和函数
```js
function deepClone(obj, hash = new WeakMap()) {
  if (typeof obj === 'object') {

  } else {
    return obj;
  }
  if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);
  // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝
  if (typeof obj !== "object") return obj;
  // 是对象的话就要进行深拷贝
  if (hash.get(obj)) return hash.get(obj);
  let cloneObj = new obj.constructor();
  // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身
  hash.set(obj, cloneObj);
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 实现一个递归拷贝
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  return cloneObj;
}
```
## CommonJS 和 AMD/CMD 规范，以及ES6的模块？
* AMD规范，即异步模块加载机制。核心是预加载，先对依赖的全部文件进行加载，加载完了再进行处理。
* CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
模块加载的顺序，按照其在代码中出现的顺序。
## JS的隐式转换？
在使用不同类型的值进行操作时，JavaScript会自动进行类型转换。
* 我们在对各种非Number类型运用数学运算符(- * /)时，会先将非Number类型转换为Number类型。
* 我们在对各种非Number类型运用数学运算符(+)时： （以下 3 点，优先级从高到低）
  * 当一侧为String类型，会将另一侧转换为字符串类型并进行字符串拼接。
  * 当一侧为Number类型，另一侧为非字符串的其他原始类型，则将原始类型转换为Number类型。
  * 当一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后拼接。
* 当我们使用逻辑语句（例如if while for）时，条件值将转为Boolean值，只有 null undefined '' NaN 0 false 这几个是 false，其他的情况都是 true，比如 {} , []。。
* 当我们使用`==`时： 
  * NaN和其他任何类型比较永远返回false（包括和他自己）。
  * Boolean 和其他任何类型比较，Boolean 首先被转换为 Number 类型。
  * String和Number比较，先将String转换为Number类型。
  * null == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false。
  * 原始类型和引用类型做比较时，引用类型会依照ToPrimitive规则转换为原始类型。
# 高级
## 会babel插件开发吗？
Babel编译是一个code to code的过程，整个流程分为三步：
* 解析（parse）：将源码解析成抽象语法树(AST)
* 转换（transform）：遍历AST，并使用babel api对AST节点进行增删改，babel 维护一个称作 Visitor 的对象，这个对象定义了用于 AST 中获取具体节点的方法，如果当前节点的类型匹配 visitor 中的类型，就会执行对应的方法，
遍历 AST 节点的时候会遍历两次（进入和退出），这样命中目标节点并进行逻辑处理。
* 生成（generate）：将转换后的 AST 转换成代码，同时可以创建Source Map映射。
编写一个文件，里面一个函数，返回值是一个指定类型的对象，visitor就是其中最主要的对象，其他都是一些配置。
在babel.config.json里的plugins，加上这个文件，就能进行转换了。
> AST可视化平台：https://astexplorer.net/
