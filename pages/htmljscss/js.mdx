# 初级
## var，let，const，死区？
var，let，const声明用法是一样，都是定义变量，var的声明会被提升到全局作用域或函数作用域，但仍然在原地方赋值。let，const并不会声明提升，因此在声明之前的代码区域就是暂时性死区。
## call，apply，bind的区别？
三者的功能都是用来改变函数中的 this 指向。
* call() 方法是预定义的 JavaScript 方法。它可以用来调用所有者对象作为参数的方法。通过 call()，您能够使用属于另一个对象的方法。call传入的参数数量不固定，第一个参数代表函数内的this指向，从第二个参数开始往后，每个参数被依次传入函数。 
```js
  const person = {
    fullName: function (country, city) {
      return this.firstName + this.lastName + " " + country + " " + city
    }
  }
  const newPerson = {
    firstName: "fu",
    lastName: "chaoyang",
  }
  person.fullName.call(newPerson, 'china', 'xian') // fuchaoyang china xian 
```
* apply() 对比 call() 仅参数上的不同：接受两个参数，第一个参数指定了函数体内的this指向。第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply方法把这个集合中的元素作为参数传递给被调用的函数。
```js
  const person = {
    fullName: function (country, city) {
      return this.firstName + this.lastName + " " + country + " " + city
    }
  }
  const newPerson = {
    firstName: "fu",
    lastName: "chaoyang",
  }
  person.fullName.apply(newPerson, ['china', 'xian']) // fuchaoyang china xian
```
* bind() 相对 call() 而言，仅绑定新对象，不立即执行。
```js
  const person = {
    fullName: function (country, city) {
      return this.firstName + this.lastName + " " + country + " " + city
    }
  }
  const newPerson = {
    firstName: "fu",
    lastName: "chaoyang",
  }
  person.fullName.bind(newPerson, 'china', 'xian') // 打印出fullName函数
  person.fullName.bind(newPerson, 'china', 'xian')() // fuchaoyang china xian
```
> 手写call函数
>```js
>  // call实现
>  Function.prototype.myCall = function (context) {
>    const arg = [...arguments].slice(1)
>    const fn = Symbol()
>    context[fn] = this
>    const result = context[fn](...arg)
>    delete context[fn]
>    return result
>  }
>```
## 说一下原型和原型链？
JavaScript 中，万物皆对象，对象分为普通对象和函数对象。
所有的函数都是函数对象（`typeof f === 'function'`），其他都是普通对象（`typeof o === 'object'`）。

JS在没有类`class`前，创建一个对象都是通过 `new 函数()` 来实现的（也就是构造函数），例如：
```js
var a = new Object() // 此时a是{}
var a = {} // 等价于 var a = new Object()
function b() {}
var a = new b() // 此时a是{}
```
在 JavaScript 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。
其中每个函数对象都有一个prototype 属性，这个属性就是所谓的原型对象。
可以把原型对象是函数内维护的一个对象模版，当 `new 函数()` ，就会把这个对象拷贝一份返回新对象，这样就完成了对象初始化，例如：
```js
function b() {
    b.prototype.c = 1
    this.d = '2' // 在构造函数里，this指向b.prototype
}
var a = new b() // 此时a为{c: 1, d: '2'}
```
另外，JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做__proto__的内置预定义属性，
用于指向创建它的构造函数的原型对象，例如在上面👆的例子中，`a.__proto__ === b.prototype`。

每个对象都有__proto__属性，但只有函数对象才有 prototype 属性。

每个对象都有constructor（构造函数）属性，这个属性指向 prototype 属性所在的函数，
例如在上面👆的例子中，`a.constructor === b.prototype.constructor === b`。

> 注意`Function.prototype`是函数对象，但没有prototype属性，即`Function.prototype.prototype === undefined`，算是一个偏门知识点吧。

原型链：在多重继承中，一个对象可以是原型的拷贝，同时也是另一个对象的原型。
因此，当你尝试访问对象上的属性时，JavaScript引擎开始从对象自身中查找该属性，
如果没有，它会继续检查__proto__，一直到没有__proto__或者找到该属性。
如果找到最后，此属性不存在时，返回undefined。
> 原型链的最上层是`Object.prototype`

## 讲一讲js的this指针？
* 全局的this指针指向windows（在严格模式下，全局作用域中的 this 的值是 undefined）。
* 当一个函数被调用时，this被绑定为全局对象，在浏览器环境下是window对象，非严格模式下，函数中的this指向window。
* 当一个方法（当函数被保存为一个对象的属性时）被调用时，this被绑定到这个对象上。
* 如果在一个函数前面加上new关键字来调用（当构造函数用），函数中的this会被绑定到这个新对象上。
* 对象里的this指向window。例如：`a = {b: this.k}`，此时this指向windows。
* call/apply/bind，this指针会绑定指定的对象。
* 事件的this指针指向元素本身。
* 箭头函数中的this是指向箭头函数定义时的离箭头函数最近的一个函数的this。
## 手写new？
```js
//Fun为构造函数, args表示传参
function myNew(Fun, ...args) {
    // 1.在内存中创建一个新对象
    let obj = {};
    
    // 2.把新对象的原型指针指向构造函数的原型属性
    obj.__proto__ = Fun.prototype;
    
    // 3.改变this指向，并且执行构造函数内部的代码（传参）
    let res = Fun.apply(obj, args);
    
    // 4.判断函数执行结果的类型
    if (res instanceof Object) {
        return res;
    } else {
        return obj;
    }
}

let obj = myNew(One, "XiaoMing", "18");
console.log("newObj:", obj);
```
## 闭包是什么？
闭包是指一个函数可以访问和使用其定义外部的变量，让这些变量的值始终保持在内存中，同时提供很好的封装和抽象。
## 手写防抖节流？
* 防抖（debounce）：每次触发定时器后，取消上一个定时器，然后重新触发定时器。防抖一般用于用户未知行为的优化，比如搜索框输入实时提示。
  ```js
  let timer;
  function debounce(cb, time) {
    clearTimeout(timer);
    timer = setTimeout(() => {
        cb();
    }, time)
  }
  
  onInputChange(text) {
    debounce(() => {
      // 获取实时提示
    }, 100)
  }
  ```
  ```js
  // 复杂一点的
  function debounce(func, time) {
    let timer;
    return function() {
      const [that, args] = [this, arguments];
      clearTimeout(timer)
      timer = setTimeout(() => {
        func.apply(that, args);
      }, time);
    }
  }

  onInputChange = debounce((text) => {
    // 获取实时提示
  }, 1000)
  ```
* 节流（throttle）：每次触发定时器后，直到这个定时器结束之前无法再次触发该函数。一般用于可预知的用户行为的优化，比如限制按钮点击的触发频率，防止重复的提交。
```js
let previous = 0;
function throttle(cb, time) {
  const now = Date.now();
  if (now - previous > time) {
    cb();
    previous = now;
  }
}

onButtonClick() {
  throttle(() => {
    // 提交表单
  }, 1000)
}
```
```js
// 复杂一点的
function throttle(func, time) {
  let previous = 0;
  return function() {
    const [that, args] = [this, arguments];
    const now = Date.now();
    if (now - previous > time) {
      previous = now;
      func.apply(that, args);
    }
  }
}
```
## 事件循环机制？
JS是一门单线程的语言，通过事件循环机制实现单线程异步的。JS所有同步任务都在主线程上执行，即执行栈。主线程之外还存在一个任务队列(也有人称之为消息队列)，用于执行异步任务。事件循环的工作流程如下：
* 首先，检查执行栈，看看是否有同步任务需要运行。
* 如果执行栈为空，那么就查看任务队列。
* 如果任务队列中有待处理的任务，那么就将它移出队列并放入调用堆栈，以便执行它的回调函数。

在JavaScript中，任务队列可以分为宏任务队列和微任务队列。在一个事件循环迭代中，首先会执行一个宏任务，然后执行所有的微任务。当所有的微任务完成后，再执行下一个宏任务。
宏任务包括如setTimeout，setInterval，setImmediate，I/O，UI rendering等，而微任务包括如Promise,MutationObserver等。

## 捕获与冒泡？
在 HTML 中，当事件被触发时，事件会经过三个阶段：捕获阶段、目标阶段和冒泡阶段。
* 捕获阶段（Capture Phase）：从 document 对象开始，逐级向下传递，直到事件源元素。在捕获阶段，事件处理函数会按照由外向内（由父元素到子元素）的顺序被依次执行。
* 目标阶段（Target Phase）：当事件传递到事件源元素时，就进入了目标阶段。在目标阶段，事件处理函数会被执行，此时可以通过 event.target 属性获取到具体触发事件的元素。
* 冒泡阶段（Bubble Phase）：从事件源元素开始，逐级向上传递，直到 document 对象。在冒泡阶段，事件处理函数会按照由内向外（由子元素到父元素）的顺序被依次执行。

在捕获阶段中，可以通过 addEventListener() 函数的第三个参数（选项）设置 capture 选项来监听事件的捕获阶段，否则监听将在冒泡阶段触发。

事件传递过程中，如果事件处理函数调用了 event.stopPropagation() 方法，当侦听的事件是捕获时,阻断的就是捕获过程,当侦听的事件是冒泡时,阻断的就是冒泡过程。
## typeof，instantof是什么？
* typeof是一个运算符，返回值是一个字符串，用来说明变量的数据类型，可以用此来判断number, string, object, boolean, function, undefined, symbol 这七种类型。对于对象、数组、null 返回的值是 object。
* instanceof运算符用于指示一个变量是否属于某个对象的实例。返回值为布尔值。instanceof 主要的实现原理就是只要右边变量的 prototype 在左边变量的原型链上即可。
## 讲一讲es5/6/7/8/9新特点？
* **ECMAScript 5 也称为 ES5 和 ECMAScript 2009。**
    + `"use strict"` 指令。例如，使用严格模式，不能使用未声明的变量
    + `String.trim()/charAt()` 删除字符串两端的空白字符
    + `Array.isArray()/forEach()/map()/fliter()/indexOf()/reduce()`
    + `JSON.parse()/stringify()`
    + `Date.now()`
    + `Object.key()/defineProperty()/getPrototypeOf()`等
    + 属性 Getter 和 Setter
* **ECMAScript 6，也被称为ES6和ES2015，是JavaScript的第六个版本**
    + let 和 const 以及块级作用域，在ES6之前，JavaScript只有全局作用域和函数作用域，没有块级作用域。
    + 模板字符串
    + `String.startWith()/endWith()`
    + 箭头函数
    + 函数参数的默认值，剩余参数
    + 解构赋值，展开运算符
    + 对象字面量的增强：属性和方法的简洁表示法，方括号表示法
    + `Object.keys()/values()/entries()/assign()`
    + 全局作用域中的 this 指向，在严格模式下，全局作用域中的 this 的值是 undefined。在非严格模式下，它会指向全局对象（浏览器中是 window 对象，Node.js 中是 global 对象）。
    + `Array.includes()/find()/from()/fill()`
    + set和map数据结构
    + 遍历器与for…of循环
* **ES2016（ES7）**
    + 幂运算符** 但一般也没有什么需求会用到幂乘
    + `Array.prototype.includes()`，第二个参数是从第几个下标开始搜，默认0
* **ES2017 ES8**
    + `Object.values`, `Object.entries`
    + 结尾允许逗号
    + async异步函数
* **ES2018 ES9**
    + 异步循环，同步循环中调用能引起等待的异步函数，是不会达到预期目的，循环本身依旧保持同步，并在内部异步函数之前完成。因此新增异步循环`for await(let i of array)`
    + 异步的finally
    + 对象的展开运算符，这项特性在ES6中已经引入，但是仅限于数组。
* **ES2019 ES10**
    + catch的参数e可以省略掉
    + `Object.fromEntries()`方便地将键值对列表（例如 Map、数组(符合键值对的)等）转换为一个对象。
    + `Array.flat()`能将高维数组降一维。
* **ES 2020 (ES11)**
    + 可选链操作符
    + BigInt 它是JavaScript的第7个原始类型，可安全地进行大数整型计算。 只需要在数字后面加上 n 即可。但不能将 BigInt与Number算术计算。
## `for in`, `for of`区别？
* `for in`循环返回的值都是对象的键值名(数组即下标)，遍历顺序有可能不是按照实际数组的内部顺序，使用for… in会遍历数组/对象所有的可枚举属性，包括继承属性，原型。所以不适合遍历数组，更适合遍历对象。
* for… of 循环用来获取一对键值对中的值，相对于forEach而言可以与 break、continue和return 配合使用，可以随时退出循环。但for…of循环内部调用的是数据结构的Symbol.iterator方法。
因此不能遍历对象，因为没有迭代器对象，可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、Generator 对象，以及字符串。
> 在ECMAScript规范中定义了 「数字属性应该按照索引值⼤⼩升序排列，字符串属性根据创建时的顺序升序排列。」在这⾥我们把对象中的数字属性称为 「排序属性」，在V8中被称为 elements，字符串属性就被称为 「常规属性」， 在V8中被称为 properties。
## 遍历对象的几种方法？
* `for...in`
* `Object.keys()`，参数是一个对象，返回是该对象的key数组
* `Object.values()`，参数是一个对象，返回是该对象的value数组
* `Object.entries()`，返回值为Object.values()与Object.keys()的结合，返回一个二维数组，每个小数组都是[ [属性名，属性值],[属性名，属性值] ]
* `Object.getOwnPropertyNames()`，其返回结果与Object.keys()相似，但会返回对象得所有属性，包括了不可枚举属性
## JS 的array的函数中，有哪些是直接修改数组本体？
* 改变原数组的方法：
`pop()`,`push()`, `shift()`,`unshift()`,`splice()`,`sort()`,`reverse()`
* 不改变原数组的方法：
`slice()`,`concat()`,`map()`
## 赋值/浅拷贝/深拷贝的区别？如何实现一个深拷贝？
* 赋值是拷贝的对象指针，整个对象都是共用的。
* 浅拷贝是拷贝一层，对象的内容仍是共用的，`Object.assign()`，拓展运算符都是浅拷贝。
* 深拷贝是递归拷贝深层次，`JSON.stringify()`是深拷贝，但是会忽略undefined、symbol和函数。
```js
// 一个简单的深拷贝
function clone(target) {
    if (typeof target === 'object') {
        let cloneTarget = Array.isArray(target) ? [] : {}; // 考虑数组
        for (const key in target) {
            cloneTarget[key] = clone(target[key]);
        }
        return cloneTarget;
    } else {
        return target;
    }
};
```
## NodeJS能用ES6模块吗？CommonJS 和 ES6模块的区别是什么？

JS能写前端web，也能写NodeJS。
* Node.js 后端应用由模块组成，其模块系统采用 CommonJS 规范，它并不是 JavaScript 语言规范的正式组成部分。
* 前端的模块系统则采用ES6模块规范，这是 JavaScript 语言规范的正式组成部分。

但是现在技术进步了，后端也能用ES6模块规范（NodeJS支持），前端也能用Common JS规范（Webpack支持）。
* Node.js 默认用CommonJS规范，但也可以用ES6模块规范，但要求 ES6 模块采用.mjs后缀文件名。
也就是说，只要脚本文件里面使用import或者export命令，那么就必须采用.mjs后缀名。
Node.js 遇到.mjs文件，就认为它是 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定"use strict"。
如果不希望将后缀名改成.mjs，可以在项目的package.json文件中，指定type字段为module。
一旦设置了以后，该项目里面的.js文件，就被解释用 ES6 模块。
如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成.cjs。
* 在使用webpack等打包工具的前端项目中，默认用ES6规范，但也可以使用CommonJS，通过在项目的package.json文件中，指定type字段为commonjs，具体细节与NodeJS后端略有差异。

无论在前端还是在后端，import/export和require/module.exports也是可以在一个项目中同时使用，甚至相互混用，这样做需要一些配置，但是建议尽量不要混用。

一个模块同时要支持 CommonJS 和 ES6 两种格式，也很容易：
* 如果原始模块是 ES6 格式，那么需要给出一个整体输出接口，比如export default obj，使得 CommonJS 可以用import()进行加载。
* 如果原始模块是 CommonJS 格式，那么可以加一个ES6模块包装层（import该CommonJS 模块，然后再export出去）。
```js
// CommonJS模块的ES6模块包装层
import cjsModule from '../index.js'; // index.js是CommonJS规范的
export const foo = cjsModule.foo; 
```

ES6模块和Commonjs模块的相同点就是，二者对于同一模块多次加载都只会执行一次模块内代码，即首次加载执行，后面加载模块不执行其内部代码。

ES6模块 和 CommonJS的区别在于用法，加载时机和方式不同：

* CommonJS 模块使用require()加载和module.exports输出，require()是代码运行阶段同步加载JS文件的（运行时加载），后面的代码必须等待这个命令执行完（只加载JS文件，不执行JS文件内容）才会执行。
* ES6 模块使用import加载和export输出，为了不影响dom渲染异步加载JS文件，在JS代码静态解析阶段分析依赖关系，在代码运行前分析出export和import对应符号引用（同样只加载JS文件，不执行JS文件内容）。

> JS代码在被JS引擎加载后，分为两个阶段：1、静态分析阶段（我们常说的编译阶段）2、运行阶段。静态分析阶段的主要工作是解析源码生成字节码。
> ES6模块就是在静态分析阶段实现export和import的分析解析。

> 静态分析 & 静态作用域：如果一门语言的作用域是静态作用域，那么符号之间的引用关系能够根据程序代码在编译时就确定清楚，在运行时不会变。某个函数是在哪声明的，就具有它所在位置的作用域。
> 它能够访问哪些变量，那么就跟这些变量绑定了，在运行时就一直能访问这些变量，这是固定的，这是非常有利于编译器做优化的。
> 因此export命令后面只能跟着声明式语句，而不能跟表达式（如变量名，字面量）。因为变量只有在声明时，才会产生一个变量引用的符号。
> 另外，ES6模块的export {} 中 {} 不是一个对象简写形式，更不是一个对象，而是export {} 语法组成部分，用作收集符号用。
> 另外，CommonJS的module.exports不是模块内部的变量，而是外部传入模块的变量，所以一旦模块内部代码对于exports变量做了修改，其实就是对于外部该变量做了修改，
> 因此模块代码未执行完，模块的输出module.exports也是有值的，因为这是外部值。

* ES6模块是在静态解析阶段分析import/export的输入输出的常/变量或函数，将其解析为一个“符号引用”（既不是一个对象，也不是一个变量，只是一种静态定义，一个简单的引用符号），
外部可以通过符号引用直接获取到对应模块中输出变量的实时数据。由于ES6输入的模块变量只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。
* CommonJS则在运行阶段加载模块输出对象，由于只作用于运行时导致完全没办法在编译时做“静态优化”，挂载在该对象上数据都是拷贝数据（浅拷贝），和原模块中的输出变量没有关系了。
外部获取module.exports，其实获取的是缓存数据（值都是初始化后的初始值），而不是原模块内的实时数据。如果访问原模块内的实时数据，通过函数返回内部值仍然是可以的。

> 建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。

但人们往往说ES6模块是异步的，为什么呢？因为Common JS肯定是同步的，由于 Node.js 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以 CommonJS 规范比较适用。
但ES6模块最初用于web，而传统的浏览器引入JS文件的方式就是使用script标签导入。
但是为了让script标签能够区分 模块JS文件 和 非模块JS文件，所以给script标签加入了 type = "module" 属性，来告诉浏览器引入的是ES6模块JS文件。
然后其他js文件内部就可以使用`import xxx`来引入该ES6模块JS文件里的内容了，就这样实现了模块化。
而设置了 type="module"的script标签，相当于带了 defer属性，即异步加载JS文件，不阻塞DOM构建，且会等DOM构建完成后，才执行JS模块代码（script标签默认是同步加载的）。


## AMD/CMD 规范，以及ES6的模块？
AMD/CMD都是浏览器的
CMD 推崇依赖就近（用的时候再声明引用的依赖），AMD 推崇依赖前置（先声明引用的依赖）。
* AMD规范，即异步模块加载机制。require/define，核心是预加载，先对依赖的全部文件进行加载，加载完了再进行处理。解决的是JS加载引起页面卡顿的问题。
* CMD规范，是一个同步模块定义，require/define，按不同的先后依赖关系对 JavaScript 等文件的进行加载工作，确保各个JS文件的先后加载顺序，确保避免了以前因某些原因某个文件加载慢而导致其它加载快的文件需要依赖其某些功能而出现某函数或某变量找不到的问题。
* CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
模块加载的顺序，按照其在代码中出现的顺序。
## JS的隐式转换？
在使用不同类型的值进行操作时，JavaScript会自动进行类型转换。
* 我们在对各种非Number类型运用数学运算符(- * /)时，会先将非Number类型转换为Number类型。
* 我们在对各种非Number类型运用数学运算符(+)时： （以下 3 点，优先级从高到低）
  * 当一侧为String类型，会将另一侧转换为字符串类型并进行字符串拼接。
  * 当一侧为Number类型，另一侧为非字符串的其他原始类型，则将原始类型转换为Number类型。
  * 当一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后拼接。
* 当我们使用逻辑语句（例如if while for）时，条件值将转为Boolean值，只有 null undefined '' NaN 0 false 这几个是 false，其他的情况都是 true，比如 {} , []。。
* 当我们使用`==`时： 
  * NaN和其他任何类型比较永远返回false（包括和他自己）。
  * Boolean 和其他任何类型比较，Boolean 首先被转换为 Number 类型。
  * String和Number比较，先将String转换为Number类型。
  * null == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false。
  * 原始类型和引用类型做比较时，引用类型会依照ToPrimitive规则转换为原始类型。
# 高级
## 会babel插件开发吗？
Babel编译是一个code to code的过程，整个流程分为三步：
* 解析（parse）：将源码解析成抽象语法树(AST)
* 转换（transform）：遍历AST，并使用babel api对AST节点进行增删改，babel 维护一个称作 Visitor 的对象，这个对象定义了用于 AST 中获取具体节点的方法，如果当前节点的类型匹配 visitor 中的类型，就会执行对应的方法，
遍历 AST 节点的时候会遍历两次（进入和退出），这样命中目标节点并进行逻辑处理。
* 生成（generate）：将转换后的 AST 转换成代码，同时可以创建Source Map映射。
编写一个文件，里面一个函数，返回值是一个指定类型的对象，visitor就是其中最主要的对象，其他都是一些配置。
在babel.config.json里的plugins，加上这个文件，就能进行转换了。
> AST可视化平台：https://astexplorer.net/
## 为什么在JS中0.1+0.2!=0.3？以及IEE 754标准

JavaScript使用Number类型表示数字（整数和浮点数），遵循 IEEE 754 标准 通过64位来表示一个数字。

首先，计算机无法直接对十进制的数字进行运算，这是硬件物理特性已经决定的。这样运算就分成了两个部分：
先按照IEEE 754转成相应的二进制，然后按照二进制运算。

回到0.1+0.2的例子上，首先转成二进制后，二进制数字是无限循环的，但是由于IEEE 754尾数位数限制，
需要将后面多余的位截掉，这样在进制之间的转换中精度已经损失。

由于指数位数不相同，运算时需要对阶运算 这部分也可能产生精度损失，两步的精度损失最后的结果转换成十进制之后就是0.30000000000000004。

> 只要是遵循遵循 IEEE 754 标准的语言都会有这个问题。
## JS的垃圾回收机制？

有两种垃圾回收策略：

* 标记清除：标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁。
* 引用计数：它把对象是否不再需要简化定义为对象有没有其他对象引用到它。如果没有引用指向该对象（引用计数为 0），对象将被垃圾回收机制回收。

标记清除的缺点：

* 内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块。
* 分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢。

引用计数的缺点：

* 需要一个计数器，所占内存空间大，因为我们也不知道被引用数量的上限。
* 解决不了循环引用导致的无法回收问题。
